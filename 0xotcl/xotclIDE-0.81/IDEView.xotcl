# automatically generated from XOTclIDE
# script require component {IDEBaseGUI IDECore}
@ Component IDEView {
description {There are the basis browser for XOTclIDE

1. Component Browser
2. Method Browser
3. Object Browser
4. Configuration Browser

and their subelements}
}
package provide IDEView 0.81
package require IDEBaseGUI
package require IDECore
Class IDE::AbstractClassView -superclass ::IDE::HListView
@ ::IDE::AbstractClassView idemeta component IDEView
IDE::AbstractClassView instproc askForItemChange {} {
    [my info parent]::methodedit askForModification
}
IDE::AbstractClassView instproc browseChildren actual {
    if {[Object isclass $actual]} {
        IDE::HeritageBrowser newBrowserChild $actual
    } else {
        my upsMessage "$actual is not a class"
    }
}
IDE::AbstractClassView instproc browseHeritage actual {
    if {[Object isclass $actual]} {
        IDE::HeritageBrowser newBrowser $actual
    } else {
        my upsMessage "$actual is not a class"
    }
}
IDE::AbstractClassView instproc createInstance actual {
    if {[$actual istype Class]} {
        set obj [IDE::System createInstance $actual]
        if {$obj ne ""} {$obj inspect}
    }
}
IDE::AbstractClassView instproc exportToFile actual {
    global tcl_platform
    my instvar vclass
    if {$tcl_platform(platform) eq "windows"} {
        regsub -all :: $actual _ name
    } else {
        set name $actual
    }
    set file [IDE::Dialog getSaveFile $name.xotcl]
    if {$file eq ""} return
    set fh [open $file w]
    if {[$vclass istype IDE::ProcsGroup]} {
        set body [$vclass getBody]
    } else {
        set body [IDE::Component getObjectBody $actual]
    }
    puts -nonewline $fh $body
    close $fh
}
IDE::AbstractClassView instproc fillMenuStruct ms {
    $ms enablementHandler [self]
    $ms addCommand2 {Heritage Browser} [list [self] dispatchWithSelected browseHeritage] isValidSelection
    $ms addCommand2 {Children Browser} [list [self] dispatchWithSelected browseChildren] isValidSelection
    $ms addCommand2 {Search References} [list [self] dispatchWithSelected searchUsage] isValidSelection
    $ms addCommand2 {Track This Class} [list [self] dispatchWithSelected trackClass] isValidSelection
    $ms addCommand2 {Create Instance} [list [self] dispatchWithSelected createInstance] isValidSelection
    $ms addCommand2 {Inspect All Instances} [list [self] dispatchWithSelected inspectAllInstances] isValidSelection
    $ms addCommand2 {Export To File} [list [self] dispatchWithSelected exportToFile] isValidSelection
    next
}
IDE::AbstractClassView instproc inspectAllInstances actual {
    if {[$actual istype Class]} {
        IDE::ObjectBrowser browseAllInstances $actual
    } elseif {[Object isobject $actual]} {
        $actual inspect
    }
}
IDE::AbstractClassView instproc searchUsage actual {
    if {[Object isclass $actual]} {
        IDE::MethodBrowser searchClassUsage $actual
    } else {
        my upsMessage "$actual is not a class"
    }
}
IDE::AbstractClassView instproc trackClass actual {
    if {[Object isclass $actual]} {
        $actual trackOn
    } else {
        IDE::Dialog error "I can track only classes"
    }
}
Class IDE::ArrayBrowser -superclass {::IDE::Browser ::IDE::GUICommands} -parameter {vobject varray {atHead 1}}
@ ::IDE::ArrayBrowser idemeta categories {initialize private actions}
@ ::IDE::ArrayBrowser idemeta categoriesMethods {{getTitle getMenuStruct fillMenuStruct specificInit} dispatchWithKey {addKey editSave initContents inspectAsObject inspectAsObjectList removeKey selectKey}}
@ ::IDE::ArrayBrowser idemeta component IDEView
IDE::ArrayBrowser instproc addKey {} {
    my instvar varray
    set key [IDE::IDialogEntry getValue {Enter new key name}]
    if {$key eq ""} return
    my varAction set ${varray}($key) {}
    [self]::keys addItem $key
    [self]::keys setSelectedItem $key
}
IDE::ArrayBrowser instproc dispatchWithKey procName {
    set actual [[self]::keys selectedItem]
    if {$actual ne ""} {
        my $procName $actual
    }
}
IDE::ArrayBrowser instproc editSave value {
    my instvar varray
    set key [[self]::keys selectedItem]
    if {$key eq ""} return
    my varAction set ${varray}($key) $value
}
IDE::ArrayBrowser instproc fillMenuStruct aMenuStruct {
    $aMenuStruct enablementHandler [self]

    $aMenuStruct addCommand2 {Add Key} [list [self] addKey] isValidSelection
    $aMenuStruct addCommand2 {Remove Key} [list [self] dispatchWithKey removeKey] isValidSelection
    $aMenuStruct addCommand2 {Inspect As Object} [list [self] dispatchWithKey inspectAsObject] isValidSelection
    $aMenuStruct addCommand2 {Inspect As Object List} [list [self] dispatchWithKey inspectAsObjectList] isValidSelection
    $aMenuStruct addCommand2 {Refresh} [list [self] initContents]
}
IDE::ArrayBrowser instproc getMenuStruct {} {
    IDE::MenuStruct create [self]::ms Array 0
}
IDE::ArrayBrowser instproc getTitle {} {
    return Array
}
IDE::ArrayBrowser instproc initContents {} {
    my instvar varray
    [self]::keys setList [my varAction array names $varray]
}
IDE::ArrayBrowser instproc inspectAsObject key {
    my instvar varray
    set obj [my varAction set ${varray}($key)]
    if {[Object isobject $obj]} {
        $obj inspect
    } else {
        IDE::Dialog error "$obj in not xotclide object"
    }
}
IDE::ArrayBrowser instproc inspectAsObjectList key {
    my instvar varray
    set list [my varAction set ${varray}($key)]
    set objects [list]
    foreach obj $list {
        if {[Object isobject $obj]} {
            lappend objects $obj
        }
    }
    if {[llength $objects]>0} {
        IDE::ObjectBrowser browseObjectsList $objects
    } else {
        IDE::Dialog message "There are no objects in the list"
    }
}
IDE::ArrayBrowser instproc isValidSelection {} {
    expr {[my set actual] ne ""}
}
IDE::ArrayBrowser instproc removeKey key {
    my instvar varray
    my varAction unset ${varray}($key)
    [self]::keys removeItem $key
}
IDE::ArrayBrowser instproc selectKey key {
    my instvar varray
    my set actual $key
    [self]::edit setTextControler [my varAction set ${varray}($key)] [self]
}
IDE::ArrayBrowser instproc specificInit {} {
    my instvar win vobject varray
    my set actual {}

    panedwindow $win.panedwindow -orient horizontal

    IDE::NListView create [self]::keys $win.keys -notify [self] -notifyProc selectKey -height 25
    IDE::MethodEdit [self]::edit $win.edit -width 40

    $win.panedwindow add $win.keys -sticky news
    $win.panedwindow add $win.edit -sticky news

    pack $win.panedwindow -fill both -expand yes

    my initContents
    my setTitleAddition "$vobject : $varray"
    next
}
IDE::ArrayBrowser instproc varAction args {
    my instvar vobject
    if {$vobject ne ""} {
        $vobject eval $args
    } else {
        namespace eval :: $args
    }
}
IDE::ArrayBrowser proc inspectArray {object array} {
    set br [my create [Object autoname abrowser] [Object autoname .abrowser] -vobject $object -varray $array]
    return $br
}
IDE::ArrayBrowser proc inspectGlobalArray array {
    set br [my create [Object autoname abrowser] [Object autoname .abrowser] -vobject {} -varray $array]
    return $br
}
Class IDE::ClassDefinition -superclass ::IDE::Browser -parameter {{superclassList {}} classView {mode create} {parameter {}} className}
@ ::IDE::ClassDefinition idemeta categories {initialize list_manipulation private}
@ ::IDE::ClassDefinition idemeta categoriesMethods {{getTitle createSystemMenu setClassesList specificInit} {upListElem downListElem delFromList addToList} getParameter}
@ ::IDE::ClassDefinition idemeta component IDEView
IDE::ClassDefinition instproc actionCreate {} {
    my instvar classView mode className
    if {[my checkClassView]} {
        if {$mode eq "redefine"} {
            set parameter [my getParameter]
            set superclass [[self]::superclass getList]
            if {$parameter!=[$className info parameter]} {
                $className parameter $parameter
            }
            if {$superclass!=[$className info superclass] &&
                !($superclass eq "" && [$className info superclass] eq "::xotcl::Object")} {
                if {$superclass eq ""} {set superclass ::xotcl::Object}
                $className superclass $superclass
            }
        } else {
            if {[set def [my getClassDefinition]] eq ""} return
            $classView editSave $def
        }
    }
    my destroy
}
IDE::ClassDefinition instproc actionTemplate {} {
    my instvar classView
    set def [my getClassDefinition]
    if {$def eq ""} return
    if {[my checkClassView]} {
        $classView setEditText $def
        $classView set vclass {}
    }
    my destroy
}
IDE::ClassDefinition instproc addItemToList item {
    if {$item eq ""} return
    [self]::superclass addItemAtTail $item
    my setClassesList
}
IDE::ClassDefinition instproc addToList {} {
    my addItemToList [[self]::classlist selectedItem]
}
IDE::ClassDefinition instproc checkClassView {} {
    my instvar classView
    return [Object isobject $classView]
}
IDE::ClassDefinition instproc createSystemMenu {} {
    # no system menu
}
IDE::ClassDefinition instproc delFromList {} {
    my removeItemFromList [[self]::superclass selectedItem]
}
IDE::ClassDefinition instproc destroy {} {
    my instvar win
    ::destroy $win
    next
}
IDE::ClassDefinition instproc downListElem {} {
    [self]::superclass reorderSelected 1
}
IDE::ClassDefinition instproc getClassDefinition {} {
    my instvar win
    set name [$win.fname.name get]
    if {$name eq ""} {
        IDE::Dialog error "You must specify new name for the class"
        return
    }
    set parameter [my getParameter]
    if {![info complete $parameter]} {
        IDE::Dialog error "Parameter are not proper Tcl list"
        return
    }
    set def "Class $name"
    set superclass [[self]::superclass getList]
    if {[llength $superclass]>0} {
        append def " -superclass [list $superclass]"
    }
    if {$parameter ne ""} {
        append def " -parameter [list $parameter]"
    }
    return $def
}
IDE::ClassDefinition instproc getParameter {} {
    my instvar win
    set parameter [$win.fpar.parameter get 1.0 end]
    return [string range $parameter 0 [expr {[string length $parameter] - 2}]]
}
IDE::ClassDefinition instproc getTitle {} {
    return {Class Definition}
}
IDE::ClassDefinition instproc removeItemFromList sitem {
    if {$sitem ne ""} {
        [self]::superclass removeItem $sitem
        my setClassesList
    }
}
IDE::ClassDefinition instproc selectItem item {
    # only for IDE::NListView
}
IDE::ClassDefinition instproc setClassesList {} {
    my instvar compVisibility classView mode className
    if {!$compVisibility} {
        set clist [IDE::IntroProxy getClasses]
    } else {
        set clist [[$classView getActualComponentObject] getVisibleClasses]
    }
    set clist [ide::lcollect each $clist {string trimleft $each :}]
    set remove [list xotcl::Class xotcl::Object]
    if {$mode eq "redefine"} {
        lappend remove $className
    }
    set supclasses [[self]::superclass getList]
    foreach sclass $supclasses {
        lappend remove [string trimleft $sclass :]
        foreach c [$sclass info heritage] {
            lappend remove [string trimleft $c :]
        }
        foreach c [IDE::IntroProxy getSubclassesDeep $sclass] {
            lappend remove [string trimleft $c :]
        }
    }
    ide::lremoveAll clist $remove
    [self]::classlist setList $clist
}
IDE::ClassDefinition instproc specificInit {} {
    my instvar win superclassList mode className parameter

    frame $win.fname
    frame $win.buttons -relief raised -border 3
    frame $win.lframe
    frame $win.fpar

    entry $win.fname.name

    if {$mode eq "redefine"} {
        $win.fname.name insert 0 $className
        $win.fname.name configure -state disabled
        set actionText Redefine
    } else {
        set actionText Create
    }
    button $win.buttons.ok -text $actionText -command [list [self] actionCreate]
    button $win.buttons.template -text "Edit Create Statement" -command [list [self] actionTemplate]
    button $win.buttons.cancel -text "Cancel" -command "destroy $win; [self] destroy" -underline 0

    pack $win.buttons.ok $win.buttons.template $win.buttons.cancel -side left

    IDE::NListView [self]::classlist $win.lframe.classlist -notify [self] -doubleNotifyProc addItemToList
    IDE::NListView [self]::superclass $win.lframe.superclass -notify [self] -doubleNotifyProc removeItemFromList

    label $win.fname.lname -text Name

    pack $win.fname.lname $win.fname.name -side left

    #label $win.lsuperclasses -text Superclasses
    checkbutton $win.lframe.visibility -text "classes visible in component only" -variable [self]::compVisibility -command [list [self] setClassesList]


    button $win.lframe.addtolist -text << -command [list [self] addToList]
    button $win.lframe.delfromlist -text del -command [list [self] delFromList]
    button $win.lframe.upitem -text up -command [list [self] upListElem]
    button $win.lframe.downitem -text down -command [list [self] downListElem]

    pack $win.lframe.visibility -side bottom -anchor e
    pack $win.lframe.superclass -side left -expand yes -fill both
    pack $win.lframe.classlist -side right -expand yes -fill both
    pack $win.lframe.addtolist -anchor s -fill x
    pack $win.lframe.delfromlist -anchor n -fill x
    pack $win.lframe.upitem -fill x
    pack $win.lframe.downitem -fill x

    label $win.fpar.lparameter -text "parameter f.e. \"parameter1 {parameter2 default2} parameter3\""
    text $win.fpar.parameter -height 6
    if {$parameter ne ""} {
        $win.fpar.parameter insert 1.0 $parameter
    }
    pack $win.fpar.lparameter -anchor w
    pack $win.fpar.parameter -fill both -expand yes


    pack $win.fname -anchor w
    pack $win.lframe -expand 1 -fill both -pady 10
    pack $win.fpar -expand 1 -fill both
    pack $win.buttons -anchor w -ipady 10 -ipadx 6 -fill x

    set cancelscript "
               $win.buttons.cancel configure -state active -relief sunken
               update idletasks
               after 100
               [self] destroy"

    bind $win <Escape> $cancelscript
    bind $win <Alt-c> $cancelscript

    [self]::superclass setListUnsorted [ide::lcollect each $superclassList {string trimleft $each :}]
    my setClassesList
    next
    focus $win.fname.name
}
IDE::ClassDefinition instproc upListElem {} {
    [self]::superclass reorderSelected -1
}
IDE::ClassDefinition proc newChildClass {superclass view} {
    return [my new [Object autoname .cdbrowser] -classView $view -superclassList $superclass]
}
IDE::ClassDefinition proc newClass view {
    return [my new [Object autoname .cdbrowser] -classView $view]
}
IDE::ClassDefinition proc redefineClass {class view} {
    set superclass [$class info superclass]
    set parameter [$class info parameter]
    if {$superclass eq "::Object" || $superclass eq "::xotcl::Object"} { set superclass ""}
    return [my create [Object autoname changeBrowser] [Object autoname .cdbrowser] -classView $view -superclassList $superclass -mode redefine -parameter $parameter -className $class]
}
IDE::ClassDefinition proc unknown args {
    error "unknown method on [self] $args"
}
@ Class IDE::ClassSelector {
description {A dialog for selecting classes
interafec is
IDE::ClassSelector getClass
cancel by returning {}}
}
Class IDE::ClassSelector
@ ::IDE::ClassSelector idemeta component IDEView
IDE::ClassSelector proc getClass {} {
    set d [IDE::IDialogEntry new -volatile -message {Give class name or glob patern} -entry *]
    if {[$d prompt] ne "ok"} {
        return
    }
    set result [$d entry]

    if {[Object isobject $result] && ([$result istype Class] || [IDE::System info class] eq "::xotcl::Object")} {
        return $result
    }
    set resultl [list]
    set clist [ide::lcollect each [IDE::IntroProxy getClasses] {string trimleft $each :}]
    if {$result eq "*"} {
        set resultl $clist
    } else {
        foreach elem $clist {
            if {[string match $result $elem]} {
                lappend resultl $elem
            }
        }
    }
    if {[llength $resultl]==0} {
        IDE::Dialog message "Class or Object with name \"$result\" can not be found"
        return
    }
    set d2 [IDE::IDialogList new -volatile -message {Choose the class} -list [lsort $resultl]]
    if {[$d2 prompt] ne "ok"} {
        return {}
    }
    set result [$d2 selectedItem]
    return $result
}
IDE::ClassSelector proc getUnregisteredClass {} {
    set result [IDE::IntroProxy getUnregisteredClasses]
    if {$result eq ""} {
        IDE::Dialog message "There are no unknown xotcl classes for XOTclIDE"
        return
    }
    set d [IDE::IDialogList new -volatile -message {Choose the class} -list [lsort $result]]
    if {[$d prompt] ne "ok"} {
        return {}
    }
    set result [$d selectedItem]
    return $result
}
@ Class IDE::ClassView {
description {Warning 

vclass varible hold an actual displayed object
it can by an real Xotcl Class or
IDE::ProcsGroup
a wrapper for structure tcl procs in groups}
}
Class IDE::ClassView -superclass {::IDE::AbstractClassView ::IDE::GUICommands ::IDE::FocusPerKey} -parameter {{label Classes/Objects}}
@ ::IDE::ClassView idemeta categories {class_actions service private user_actions initialize}
@ ::IDE::ClassView idemeta categoriesMethods {{classTemplate copyClass classWizard deleteClass} getActualComponentObject {setEditText changeViewType refreshView setViewType dispatchWithSelectedNoGroup selectItem selectFor} {renameTclProcsGroup newTclProcsGroup createTclProcsGroup moveToComp} {getMenuStruct fillMenuStruct init}}
@ ::IDE::ClassView idemeta component IDEView
IDE::ClassView instproc buttonDoublePush {} {
    my instvar win selectedIndex listItems
    set currsel [lindex [$win.listbox curselection] 0]
    if {$currsel ne ""} {
        my selectItem [string trimleft [lindex $listItems $currsel]]
    }
}
IDE::ClassView instproc buttonPush {} {
    my instvar win selectedIndex listItems
    set currsel [lindex [$win.listbox curselection] 0]
    if {$currsel ne "" && $currsel!=$selectedIndex} {
        if {![my askForItemChange]} {
            my setSelectedIndex $selectedIndex 0
        } else {
            set selectedIndex $currsel
            my selectItem [string trimleft [lindex $listItems $currsel]]
        }
    }
    focus [my getFocusWin]
}
IDE::ClassView instproc canModifyComponent {} {
    my instvar cobj
    if {[$cobj isPersistent] && ![$cobj questForChange]} {
        return 0
    } else {
        return 1
    }
}
IDE::ClassView instproc changeHeritageView {} {
    if {[my exists vcomponent]} {
        my selectFor [my set vcomponent]
    }
}
IDE::ClassView instproc changeViewType type {
    my set vtype $type
    if {[my exists vcomponent]} {
        my selectFor [my set vcomponent]
    }
}
IDE::ClassView instproc classTemplate {} {
    my unselect
    [my info parent]::methodedit setTextControler {Class YourClass -superclass YourSuperClass} [self]
}
IDE::ClassView instproc classWizard mode {
    set actual [my selectedItem]
    switch $mode {
        new {
            my setViewType {Classes}
            IDE::ClassDefinition newClass [self]
        }
        newChild {
            if {$actual eq ""} return
            IDE::ClassDefinition newChildClass $actual [self]
        }
        redefine {
            if {$actual eq ""} return
            IDE::ClassDefinition redefineClass $actual [self]
        }
    }
}
IDE::ClassView instproc copyClass actual {
    my instvar vcomponent
    set cobj [IDE::Component getCompObjectForNameIfExist $vcomponent]
    set newname [IDE::IDialogEntry getValue "Give Object/Class Copy Target Name"]
    if {$newname eq ""}  return
    if {[Object isobject $newname]} {
        IDE::Dialog message "Object $newname already exists!"
        return
    }
    set targetComp [IDE::IDialogList getListItem "Select target Component" [IDE::Component getComponentNames]]
    if {$targetComp eq ""} return
    $cobj copyClassOrObject $actual $newname $targetComp
}
IDE::ClassView instproc createTclProcsGroup {name withNamespace} {
    my instvar cobj
    if {![my canModifyComponent]} return

    $cobj createTclProcsGroup $name $withNamespace
    my setViewType Procs
}
IDE::ClassView instproc deleteClass actual {
    my instvar vtype vcomponent procsGroup

    set cobj [IDE::Component getCompObjectForNameIfExist $vcomponent]
    if {$cobj eq ""} return
    if {$vtype eq "Classes"} {
        if {[llength [set subclasses [$actual info subclass]]]>0} {
            IDE::Dialog message "$actual has subclasses and can not be removed yet: [join $subclasses {, }]. Remove the subclass dependiences first"
            return
        }
        if {[llength [set subclasses [$actual info classchildren]]]>0} {
            IDE::Dialog message "$actual has nested classes and can not be removed yet: [join $subclasses {, }]. Remove the nested classes first"
            return
        }
    }
    if {![my canModifyComponent]} return
    if {![IDE::Dialog yesNo "Do you really want to delete $actual"]} return
    my removeItem $actual
    if {[my isProcView]} {
        $cobj removeProcsGroup $procsGroup
    } else {
        if {[Object isclass $actual]} {
            $cobj removeClass $actual
        } else {
            $cobj removeObject $actual
        }
        $actual destroy
    }
    [my info parent]::methodcatview selectFor {} $vtype
}
IDE::ClassView instproc dispatchWithSelectedNoGroup procName {
    set actual [my selectedItem]
    if {$actual ne ""} {
        if {[my set vtype] ne "Procs"} {
            my $procName $actual
        } else {
            my upsMessage {you can not do this action on Tcl procs-group}
        }
    } else {
        my upsMessage {you need to select a item for this action}
    }
}
IDE::ClassView instproc editSave skript {
    my instvar vcomponent vtype vclass treeView
    if {![my exists vcomponent]} {
        IDE::Dialog message {Select the component first}
        return
    }
    if {![info complete $skript]} {
        IDE::Dialog message {This is not complete Tcl-Script. Check the paratness}
        return
    }
    if {[ide::lcontain {Object Class} [lindex $skript 0]] || [Object ismetaclass [lindex $skript 0]]} {
        set dobj [lindex $skript 1]
        if {[Object isobject [lindex $skript 1]]} {
            if {[IDE::Dialog yesNo "Operation is not permited. All Object methods are lost be redefinig the Object. Use class methods 'superclass' or 'parameter' for redefining. Do you want to use 'Redefine Class Wizard' on $dobj?"] eq "yes"} {
                IDE::ClassDefinition redefineClass $dobj [self]
            }
            return
        }
    }
    # check if component is versioned
    if {![my canModifyComponent]} return

    if {[my isProcView]} {
        $vclass handleDefinitionScript $skript
        return
    }
    set newclass [string trimleft [namespace eval :: $skript] :]
    $newclass moveToComponent $vcomponent
    if {[$newclass istype Class]} {
        if {$vtype eq "Classes"} {
            if {$treeView} {
                my changeHeritageView
            } else {
                my addItem $newclass
            }
        }
    } else {
        if {$vtype eq "Objects"} {
            my addItem $newclass
        }
    }
}
IDE::ClassView instproc editSaveComment comment {
    my instvar vclass
    if {[Object isobject $vclass]} {
        $vclass setComment $comment
    }
}
IDE::ClassView instproc fillMenuStruct ms {
    $ms enablementHandler [self]
    $ms enableList isValidContext

    $ms addMenuItem [IDE::MenuCommand new -childof $ms -name Delete -command [list [self] dispatchWithSelected deleteClass] -enableList [list isValidSelection] -popdownMenu 1]
    $ms addCheckButton {Heritage View} [self]::treeView [list [self] changeHeritageView]
    $ms addMenuItem [IDE::MenuCommand new -childof $ms -name {Move To Comp.} -command [list [self] dispatchWithSelected moveToComp] -enableList [list isValidSelection] -popdownMenu 1]
    $ms addMenuItem [IDE::MenuCommand new -childof $ms -name {Copy Class/Object} -command [list [self] dispatchWithSelected copyClass] -enableList [list isValidSelection isSelectionNoGroup] -popdownMenu 1]
    $ms addCommand {New Class Template} [list [self] classTemplate]

    $ms addSeparator
    $ms addMenuItem [IDE::MenuCommand new -childof $ms -name {New Class Wizard} -command [list [self] classWizard new] -popdownMenu 1]
    $ms addMenuItem [IDE::MenuCommand new -childof $ms -name {New Child Class Wizard} -command [list [self] classWizard newChild] -enableList [list isValidSelection isSelectionClass] -popdownMenu 1]
    $ms addMenuItem [IDE::MenuCommand new -childof $ms -name {Redefine Class Wizard} -command [list [self] classWizard redefine] -enableList [list isValidSelection isSelectionClass] -popdownMenu 1]
    $ms addMenuItem [IDE::MenuCommand new -childof $ms -name {New Object Wizard} -command [list [self] newObjectWizard] -popdownMenu 1]

    set tms ${ms}::tclprocs
    IDE::MenuStruct $tms {Tcl Procs Group}
    $tms enablementHandler [self]
    $ms addCascadeMenu $tms
    $tms addCommand {New Group} [list [self] newTclProcsGroup]
    $tms addMenuItem [IDE::MenuCommand new -childof $tms -name {Rename} -command [list [self] dispatchWithSelected renameTclProcsGroup] -enableList [list isValidSelection isProcView]]

    my menuInsertions $ms

    $ms addSeparator

    next

}
IDE::ClassView instproc getActualComponentObject {} {
    my set cobj
}
IDE::ClassView instproc getMenuStruct {} {
    return [IDE::MenuStruct create [self]::ms Class 2]
}
IDE::ClassView instproc init args {
    next
    my instvar win vtype
    my set treeView 0
    ::IDE::TabButtons [self]::@stateButton $win.tb_class -states {Classes Objects Procs} -command [list [self] changeViewType]
    set vtype Classes
    pack $win.tb_class -anchor w
}
IDE::ClassView instproc isProcView {} {
    my instvar vtype vclass
    if {$vtype eq "Procs" &&
        [Object isobject $vclass] &&
        [$vclass istype IDE::ProcsGroup]} {
        return 1
    }
    return 0
}
IDE::ClassView instproc isSelectionClass {} {
    expr {[my set vtype] eq "Classes"}
}
IDE::ClassView instproc isSelectionNoGroup {} {
    expr {[my set vtype] ne "Procs"}
}
IDE::ClassView instproc isValidContext {} {
    expr {[my exists vcomponent] && [my set vcomponent] ne ""}
}
IDE::ClassView instproc moveToComp actual {
    my instvar vcomponent vclass
    IDE::IDialogList [self]::dialog -message {Choose the Component}  -list [lsort [IDE::IntroProxy getComponents]]
    if {[[self]::dialog prompt] eq "ok"} {
        set component [[self]::dialog selectedItem]
        if {$vcomponent==$component} return
        # check if source and target component can be changed
        if {![my canModifyComponent]} return
        set cobj [IDE::Component getCompObjectForName $component]
        if {[$cobj isPersistent] && ![$cobj questForChange]} return
        if {$component ne ""} {
            $vclass moveToComponent $component
            if {[$cobj isPersistent]} {
                $cobj reorderObjectDefinition
            }
            my removeItem $actual
        }
    }
    [self]::dialog destroy
}
IDE::ClassView instproc newObjectWizard {} {
    set object [IDE::IDialogEntry getValue {Specify Object name}]
    if {$object eq ""} return
    if {![info complete $object] || [llength $object]>1} {
        IDE::Dialog error "Object name should be simple word (one list element) but got '$object'"
        return
    }
    my setViewType Objects
    my editSave "Object $object"
}
IDE::ClassView instproc newTclProcsGroup {} {
    my instvar vcomponent
    if {$vcomponent eq ""} return
    IDE::TclGroupDefinition newGroup [self]
}
IDE::ClassView instproc refreshList {} {
    my selectFor [my set vcomponent]
}
IDE::ClassView instproc refreshView {} {
    my instvar vclass vtype
    set v [my info parent]::methodedit
    set editVType [[my info parent]::stateButton state]
    if {$editVType eq "Source" || $editVType eq "Splited"} {
        if {[my isProcView]} {
            set text  [$vclass getDefBody]
        } else {
            set text  [IDE::IntroProxy getObjDef $vclass]
        }
        set hasComment [$vclass hasComment]
        $v setTextControler $text [self]
        set sb [my info parent]::stateButton
        if {$editVType eq "Splited"} {
            [my info parent] @comment setTextTypeControler [$vclass getComment] Comment [self]
            $sb  setActivity 0
        } else {
            if {[Object isobject $sb]} {
                $sb  setActivity $hasComment
            }
        }
    } elseif {$editVType eq "Comment"} {
        $v setTextControler [$vclass getComment] [self]
        [my info parent]::stateButton setActivity 0
    } else {
        error {Unknown view type}
    }
}
IDE::ClassView instproc renameTclProcsGroup actual {
    my instvar vclass
    if {![$vclass istype IDE::ProcsGroup] && ![$vclass withNamespace]} return
    if {![my canModifyComponent]} return
    set newname [IDE::IDialogEntry getValue "Get new name for tcl proc group" [$vclass getObjectName]]
    if {$newname ne "" && $newname!=[$vclass getObjectName]} {
        $vclass rename $newname
        my refreshList
    }
}
IDE::ClassView instproc selectFor component {
    my instvar vcomponent vtype cobj treeView
    set vcomponent $component
    if {$component eq ""} {
        my resetList
        set cobj {}
        [my info parent]::methodcatview selectFor {} $vtype
        return
    }
    set mtype $vtype
    set cobj [IDE::Component getCompObjectForNameIfExist $vcomponent]
    if {$cobj eq ""} {error "Can find component object for $vcomponent"}
    if {$mtype eq "Procs"} {set mtype ProcsGroups}
    if {$treeView && $vtype eq "Classes"} {
        my setHList [$cobj getClassesHierarchy]
    } else {
        my setList [lsort [IDE::IntroProxy get${mtype}ForComponent $component]]
    }
    foreach s {Classes Objects Procs} n {Classes Objects ProcsGroups} {
        my @stateButton setStateAddInfo $s [format %2i [llength [IDE::IntroProxy get${n}ForComponent $component]]]
    }
    my selectItem {}
}
IDE::ClassView instproc selectItem class {
    my instvar vtype vclass procsGroup cobj
    if {[Object isobject [my info parent]::methodcatview]} {
        [my info parent]::methodcatview selectFor $class $vtype
    }
    if {$class eq ""} {
        set vclass {}
        return
    }
    if {$vtype eq "Procs"} {
        set procsGroup [$cobj getProcsGroupWithName $class]
        set vclass $procsGroup
    } else {
        set vclass $class
    }
    my refreshView
}
IDE::ClassView instproc setEditText text {
    [my info parent]::methodedit setTextControler $text [self]
    [my info parent]::methodedit ignoreNoChanges
}
IDE::ClassView instproc setViewType type {
    my @stateButton setState $type
    my changeViewType $type
}
@ Class IDE::CodeController {
description {This class is designed as mixin for IDE::TclModeEdit it can accept the
code from the edit directly.}
}
Class IDE::CodeController
@ ::IDE::CodeController idemeta component IDEView
IDE::CodeController instproc editSave skript {
    if {![info complete $skript]} {
        IDE::Dialog message {This is not complete Tcl-Script. Check the paratness}
        return
    }
    if {[lindex $skript 0] eq "proc"} {
        my handleProc $skript
    } else {
        namespace eval :: $skript
    }
}
IDE::CodeController instproc editSaveComment comment {
    my instvar actItem
    set vclass [lindex $actItem 0]
    set vtype [lindex $actItem 1]
    set method [lindex $actItem 2]
    $vclass setMethodComment $vtype $method $comment
}
IDE::CodeController instproc handleProc script {
    if {[llength $script]!=4 || [lindex $script 0] ne "proc"} {
        IDE::Dialog error "To define new tcl proc give 4 elements list\n proc ?nameSpace::?procName arguments procBody"
        return
    }
    set procname [lindex $script 1]
    set pobj [IDE::TclProcsDescription getMethodFor $procname]
    if {$pobj eq "" || ![Object isobject $pobj]} {
        IDE::Dialog error "It is not good place to define procs. Use component browser instead"
        return
    }
    [$pobj getGroupObj] handleScript $script
}
IDE::CodeController instproc refreshView {} {
    my instvar actItem
    set class [lindex $actItem 0]
    set type [lindex $actItem 1]
    set method [lindex $actItem 2]
    set v [my info parent]::methodedit
    if {[$v set vtype] eq "Comment"} {
        set comment [$class getMethodComment $type $method]
        my setTextControler $comment [self]
    } elseif {[$v set vtype] eq "Source"} {
        my setBodyTextControler $class $type $method [self]
        set sb [my info parent]::stateButton
        # procs not controlled by IDE has no ProcsGroups
        if {[Object isobject $sb] && $class ne ""} {
            set hasComment [$class hasMethodComment $type $method]
            $sb  setActivity $hasComment
        }
    }
}
IDE::CodeController instproc setBodyText {class type method} {
    my instvar actItem
    my set actItem [list $class $type $method]
    my refreshView
}
IDE::CodeController instproc setTextType {text type} {
    my setTextTypeControler $text $type [self]
}
IDE::CodeController instproc syntaxCheck {text editor} {
    # !! method is double to IDE::MethodView
    set context [PrsContext new -volatile]
    $context parseAndCheck $text
    if {[$context hasErrors]} {
        IDE::SyntaxErrorView new -errors [$context errors] -controler [self] -editor $editor -init [Object autoname .syntaxview]
        return 0
    } else {
        return 1
    }
}
Class IDE::MethodEdit -superclass ::IDE::Editor
@ ::IDE::MethodEdit idemeta component IDEView
IDE::MethodEdit instproc changeViewType type {
    my instvar vtype controler
    set vtype $type
    if {[my exists controler] && [Object isobject $controler]} {
        $controler refreshView
    }
}
IDE::MethodEdit instproc fillMenuStruct ms {
    next
    $ms addMenuItem [IDE::MenuSeparator new -childof $ms -popdownMenu 1]
    #$ms addCommand Revert "[self] revert"
    $ms addMenuItem [IDE::MenuCommand new -childof $ms -accelerator Control-s -name Save/Accept -command [list [self] save] -popdownMenu 1]
}
IDE::MethodEdit instproc haveNoChanges {} {
    expr {![my hasModifications]}
}
IDE::MethodEdit instproc ignoreNoChanges {} {
    my instvar oldtext
    set oldtext -
}
IDE::MethodEdit instproc init args {
    my set vtype Source
    next
}
IDE::MethodEdit instproc save {} {
    if {![my exists oldtext]} return
    set newtext [my getText]
    if {[IDE::System isTkNeverThan84]} {
        if {[[my getTextWindow] edit modified]} {
            my saveValue $newtext
       }
    } else {
        if {[my set oldtext]!=$newtext} {
            my saveValue $newtext
        }
    }
}
IDE::MethodEdit instproc saveForce {} {
    if {![my exists oldtext]} return
    set newtext [my getText]
    if {[my set oldtext]!=$newtext} {
        # !!! no handlung of comments
        [my set controler] editSave $newtext
        [my getTextWindow] edit modified 0
    }
}
IDE::MethodEdit instproc saveSource value {
    [my set controler] editSave $value
    [my getTextWindow] edit modified 0
}
IDE::MethodEdit instproc saveValue value {
    my instvar controler vtype
    # remove all spaces before newline
    regsub -all -line { +$} $value {} value
    if {$vtype eq "Source"} {
       my saveSource $value
    } elseif {$vtype eq "Comment"} {
       $controler editSaveComment $value
       [my getTextWindow] edit modified 0
    } else {
       error {unknown view type}
    }
}
IDE::MethodEdit instproc setBodyTextControler {tvclass tvtype tmethod controler} {
    my set vclass $tvclass
    my set vctype $tvtype
    my set method $tmethod
    set ret {}
    if {$tvtype eq "Procs"} {
        if {[Object isobject $tvclass]} {
            set pobj [$tvclass getProcObjForNameIfExist $tmethod]
            if {$pobj ne ""} {
                set ret [$pobj getBody]
            }
        }
    } else {
        set ret [IDE::IntroProxy getBody${tvtype}MethodIfExist $tvclass $tmethod]
    }
    if {$ret eq ""} {
        my setTextControler "# Method $tmethod in $tvclass was probably deleted from the System" $controler
    }
    my setTextControler $ret $controler xotcl
}
IDE::MethodEdit instproc setTextControler {text contr {type Source}} {
    my instvar win state controler oldtext
    set oldtext $text
    set controler $contr
    set state use
    if {$type eq "Source" && [$contr istype IDE::MethodView]} {
        set type xotcl
    }
    my setTypedText $text $type
}
IDE::MethodEdit instproc setTextTypeControler {text type contr} {
    my instvar win state controler oldtext
    set oldtext $text
    set controler $contr
    set state use
    my setTypedText $text $type
}
IDE::MethodEdit instproc setType type {
    my set vtype $type
}
Class IDE::CommentEdit -superclass ::IDE::MethodEdit
@ ::IDE::CommentEdit idemeta component IDEView
IDE::CommentEdit instproc fillMenuStruct ms {
    # $ms popdownMenuOnly 1
    $ms addMenuItem [IDE::MenuCommand new -childof $ms -accelerator _Control-s -name Save/Accept -command [list [self] save] -popdownMenu 1]
}
IDE::CommentEdit instproc getMenuStruct {} {
    IDE::MenuStruct create [self]::ms Edit 0 -popdownMenuOnly 1
}
IDE::CommentEdit instproc init args {
    next
    set twin [my getTextWindow]
    bind $twin <Control-s> [list [self] save]
    $twin configure -font [lindex [$twin configure -font] 3]
}
IDE::CommentEdit instproc saveValue value {
    if {$value ne "not commented"} {
        next
    }
}
IDE::CommentEdit instproc setText text {
    if {$text eq ""} {
        next "not commented"
    } else {
        next
    }
}
@ Class IDE::CompBrowser {
description {Build the main work tool for an XOTclIDE programmer

If there is Version Control available it
create its commonent from another class with
pre IDE::DB* see specificInit method
}
}
Class IDE::CompBrowser -superclass ::IDE::Browser
@ ::IDE::CompBrowser idemeta component IDEView
IDE::CompBrowser instproc changeViewType type {
    my instvar win
    if {$type eq "Splited"} {
        set etype Source
    } else {
        set etype $type
    }
    if {$type eq "Splited"} {
        $win.panedwindow add $win.comment -sticky news -height 100 -after $win.upperarea
    } else {
        if {[winfo ismapped $win.comment]} {
            $win.panedwindow forget $win.comment
        }
    }
    [self]::methodedit changeViewType $etype
}
IDE::CompBrowser instproc changeZoom {} {
    my instvar win sashpadYpos
    if {[winfo viewable $win.upperarea]} {
        $win.panedwindow forget $win.upperarea
        set sashpadYpos [lindex [$win.panedwindow proxy coord] 1]
    } else {
        $win.panedwindow add $win.upperarea -before $win.methodedit -height $sashpadYpos
    }
}
IDE::CompBrowser instproc closeWindow {} {
    if {[[self]::methodedit askForModification]} {
        next
    }
}
IDE::CompBrowser instproc getActualComponentObject {} {
    [self]::appview getActualComponentObject
}
IDE::CompBrowser instproc getTitle {} {
    return {Component Browser}
}
IDE::CompBrowser instproc initStatusBarWin win {
    my instvar statusBarTextWin
    frame $win
    label $win.label -anchor w
    set statusBarTextWin $win.label
    IDE::StateButtonActivity [self]::stateButton $win.stateBut -states {Source Comment Splited} -command [list [self] changeViewType]
    bind [winfo toplevel $win] <Alt-u> [list $win.stateBut invoke]
    pack $win.label  -side left
    pack $win.stateBut -side right
}
IDE::CompBrowser instproc refreshHItem hitem {
    set vclass [lindex $hitem 0]
    set vctype [lindex $hitem 1]
    set method [lindex $hitem 2]
    if {$vctype eq "Procs"} {
        if {[Object isobject $vclass]} {
            set cobj [$vclass getComponent]
            [self]::appview setSelectedItem [$cobj getName]
            [self]::classview::@stateButton changeStateTo "Procs"
            [self]::classview setSelectedItem [$vclass getName]
        }
    } else {
        set cobj [$vclass getCompObject]
        [self]::appview setSelectedItem [$cobj getName]
        if {[Object isclass $vclass]} {
            set needState Classes
        } else {
            set needState Objects
        }
        [self]::classview @stateButton changeStateTo $needState
        [self]::classview setSelectedItem $vclass
        [self]::methodcatview::stateButton changeStateTo $vctype
        [self]::methodcatview setSelectedItem _all_categories
    }
}
IDE::CompBrowser instproc specificInit {} {
    my instvar win vtype

    set vtype Source

    # The simplest factory pattern case in the free world
    if {[IDE::System isDatabase]} {
        set postFix DB
    } else {
        set postFix ""
    }

    panedwindow $win.panedwindow -orient vertical
    panedwindow $win.upperarea -orient horizontal

    IDE::CompView${postFix} create [self]::appview $win.upperarea.appview -focusKey {Alt-KeyPress-1} -nextFocus $win.upperarea.classview.listbox -prevFocus $win.upperarea.methodview.listbox -height 1
    IDE::TclModeEdit create [self]::methodedit $win.methodedit -height 2
    IDE::ClassView${postFix} create [self]::classview $win.upperarea.classview -focusKey {Alt-KeyPress-2} -label {Classes/Objects Alt-2} -nextFocus $win.upperarea.methodcatview.listbox -prevFocus $win.upperarea.appview.listbox  -height 1
    IDE::MethodCategoryView create [self]::methodcatview $win.upperarea.methodcatview -focusKey {Alt-KeyPress-3} -label {Categories Alt-3} -nextFocus $win.upperarea.methodview.listbox -prevFocus $win.upperarea.classview.listbox  -height 1
    IDE::MethodView${postFix} create [self]::methodview $win.upperarea.methodview  -focusKey {Alt-KeyPress-4} -label {Methods Alt-4} -prevFocus $win.upperarea.methodcatview.listbox -nextFocus $win.methodedit.text -multiselect 1 -height 1

    $win.upperarea add $win.upperarea.appview  -width 200
    $win.upperarea add $win.upperarea.classview -width 240
    $win.upperarea add $win.upperarea.methodcatview $win.upperarea.methodview -width 200

    IDE::CommentEdit create [self]::@comment  $win.comment -height 50

    $win.panedwindow add $win.upperarea -sticky news -height  220
    $win.panedwindow add $win.methodedit -sticky news -height 200

    pack $win.panedwindow -expand yes -fill both

    my initStatusBar 2 4

    next
}
IDE::CompBrowser proc newBrowser {} {
    return [my new [Object autoname .compbrowser]]
}
Class IDE::CompView -superclass {::IDE::ListView ::IDE::GUICommands ::IDE::FocusPerKey} -parameter {{label {Components Alt-1}}}
@ ::IDE::CompView idemeta categories {user_actions system_actions initialize}
@ ::IDE::CompView idemeta categoriesMethods {{createNewComponent registerTclProcs registerClass searchClass importFromSource loadFromSource newComponent renameComponent saveAsSource setVersion unloadComponent loadPackage} {refreshFromInterpreter runPkgMkIndex setAutoPath} {init fillMenuStruct getMenuStruct}}
@ ::IDE::CompView idemeta component IDEView
IDE::CompView instproc askForItemChange {} {
    [my info parent]::methodedit askForModification
}
IDE::CompView instproc changeWorkingDir {} {
    set newdir [IDE::Dialog getDir [pwd]]
    if {$newdir ne ""} {
        cd $newdir
    }
}
IDE::CompView instproc createNewComponent component {
    IDE::Component getCompObjectForName $component
    IDE::System signalComponentsChanged
}
IDE::CompView instproc editSave comment {
    my editSaveComment $comment
}
IDE::CompView instproc editSaveComment comment {
    my instvar vcomponent
    set cobj [IDE::Component getCompObjectForNameIfExist $vcomponent]
    if {$cobj ne ""} {
        $cobj setComment $comment
    }
}
IDE::CompView instproc fillMenuStruct ms {
    $ms enablementHandler [self]

    $ms addMenuItem [IDE::MenuCommand new -childof [self] -name New -command [list [self] newComponent] -popdownMenu 1]
    $ms addMenuItem [IDE::MenuCommand new -childof [self] -accelerator {Control-f} -name {Find Class} -command [list [self] searchClass] -popdownMenu 1]
    $ms addCheckButton {Ignore IDE Components} [self]::visibilityNoIDE [list [self] showComponents]
    $ms addSeparator
    $ms addMenuItem [IDE::MenuCommand new -childof [self] -name Rename -command [list [self] dispatchWithSelected renameComponent] -popdownMenu 1 -enableList [list isValidSelection]]
    $ms addMenuItem [IDE::MenuCommand new -childof [self] -name {Set Version Number} -command [list [self] dispatchWithSelected setVersion] -popdownMenu 1 -enableList [list isValidSelection]]
    $ms addMenuItem [IDE::MenuCommand new -childof [self] -name {Save as Source} -command [list [self] dispatchWithSelected saveAsSource] -popdownMenu 0 -enableList [list isValidSelection]]
    $ms addMenuItem [IDE::MenuCommand new -childof [self] -name Unload -command [list [self] dispatchWithSelected unloadComponent] -popdownMenu 1 -enableList [list isValidSelection]]
    $ms addSeparator
    IDE::MenuStruct ${ms}::spezial {Low level Functions}
    $ms addCascadeMenu ${ms}::spezial
    ${ms}::spezial addCommand {Refresh From Interp} [list [self] refreshFromInterpreter]
    ${ms}::spezial addCommand3 {Register Class From Interp} [list [self] dispatchWithSelected registerClass] isValidSelection
    ${ms}::spezial addCommand3 {Register Tcl proc From Interp} [list [self] registerTclProcs] isValidSelection

    ${ms}::spezial addCommand {Run pkg_mkIndex} [list [self] runPkgMkIndex]
    ${ms}::spezial addCommand {Change Working Dir} [list [self] changeWorkingDir]
    ${ms}::spezial addCommand {Run Script} [list [self] loadFromSource]

    #$ms addCommand {Set auto_path} [list [self] setAutoPath]
    $ms addCommand {Load Package} [list [self] loadPackage]
    $ms addCommand {Import Source} [list [self] importFromSource]
    my menuInsertions $ms
    $ms addSeparator
    $ms addCommand {Save Components} [list IDE::ComponentSaveWizard newBrowser]
    $ms addCommand {Save All} [list IDE::Component saveAllToPath]
    next
}
IDE::CompView instproc getActualComponentObject {} {
    set actual [my selectedItem]
    if {$actual eq ""} return
    return [IDE::Component getCompObjectForNameIfExist $actual]
}
IDE::CompView instproc getMenuStruct {} {
    IDE::MenuStruct create [self]::ms Component 0
}
IDE::CompView instproc importFromSource {} {
    set source [IDE::Dialog getOpenFile {{{Tcl Files} *.tcl} {{Xotcl Files} *.xotcl} {{All files} *}}]
    if {$source ne ""} {
        IDE::Component importCompsFromFile $source
        IDE::System signalComponentsChanged
    }
}
IDE::CompView instproc init args {
    next
    my instvar visibilityNoIDE
    set visibilityNoIDE [IDE::System isIgnoreIDEComponents]
    my showComponents
}
IDE::CompView instproc loadFromSource {} {
    set source [IDE::Dialog getOpenFile {{{Tcl Files} *.tcl} {{Xotcl Files} *.xotcl} {{All files} *}}]
    if {$source ne ""} {
        IDE::Component loadCompFromFile $source
    }
}
IDE::CompView instproc loadPackage {} {
    IDE::PackageLoader newBrowser
}
IDE::CompView instproc newComponent {} {
    set component [IDE::IDialogEntry getValue {Enter the component name}]
    if {$component ne ""} {
        if {![regexp {^[\w:]+$} $component]} {
            IDE::Dialog error {Wrong name for the component}
            return
        }
        # The component should not already exits
        if {$component ne "" && [IDE::Component getCompObjectForNameIfExist $component] eq ""} {
            my createNewComponent $component
        }
    }
}
IDE::CompView instproc refreshFromInterpreter {} {
    IDE::CommentsContainer parseAndCleanMeta
    IDE::Component initFromInterpreter
    my showComponents
}
IDE::CompView instproc refreshView {} {
    my instvar vcomponent
    set v [my info parent]::methodedit
    $v setTextControler [[IDE::Component getCompObjectForNameIfExist $vcomponent] getComment] [self]
}
IDE::CompView instproc registerClass actual {
    set cls [IDE::ClassSelector getUnregisteredClass]
    if {$cls eq ""} return
    if {![[my info parent]::classview canModifyComponent]} return
    $cls moveToComponent $actual
}
IDE::CompView instproc registerTclProcs {} {
    IDE::ImportMethodView startBrowserForComponent [IDE::Component getCompObjectForNameIfExist [my set vcomponent]]
}
IDE::CompView instproc renameComponent component {
    set compObj [IDE::Component getCompObjectForName $component]
    set ret [IDE::IDialogEntry getValue {Enter new name for the component} [$compObj getName]]
    if {$ret ne "" && $ret!=[$compObj getName]} {
        if {![regexp {^[\w:]+$} $ret]} {
            IDE::Dialog error {Wrong name for the component}
            return
        }
        $compObj rename $ret
        IDE::System signalComponentsChanged
    }
}
IDE::CompView instproc runPkgMkIndex {} {
    pkg_mkIndex -direct [pwd] *.xotcl
    IDE::Dialog message "command \"pkg_mkIndow -direct [pwd] *.xotcl\" succesful finished"
}
IDE::CompView instproc saveAsSource actual {
    set source [IDE::Dialog getSaveFile $actual.xotcl]
    if {$source ne ""} {
        [IDE::Component getCompObjectForName $actual] saveAsScript $source
    }
}
IDE::CompView instproc searchClass {} {
    set class [IDE::ClassSelector getClass]
    if {$class eq ""} return
    my setSelectedItem [$class getComponentName]
    if {[$class isclass]} {
        set shouldView Classes
    } else {
        set shouldView Objects
    }
    if {[[my info parent]::classview set vtype]!=$shouldView} {
        [my info parent]::classview::stateButton changeStateTo $shouldView
    }
    [my info parent]::classview setSelectedItem [string trimleft $class :]
}
IDE::CompView instproc selectItem item {
    if {[Object isobject [my info parent]::classview]} {
        [my info parent]::classview selectFor $item
    }
    my set vcomponent $item
    my refreshView
    [my info parent] setTitleAddition $item
}
IDE::CompView instproc setAutoPath {} {
    global auto_path
    set ret [IDE::IDialogEntry getValue {Set auto_path global varible} $auto_path]
    if {$ret ne ""} {
        set auto_path $ret
    }
}
IDE::CompView instproc setVersion actual {
    set appObj [IDE::Component getCompObjectForName $actual]
    set ret [IDE::IDialogEntry getValue {Set the Version Number} [$appObj getVersionNumber]]
    if {$ret ne ""} {
        if {![catch {expr {$ret+0}}]} {
            $appObj setVersionNumber $ret
        } else {
            IDE::Dialog error "$ret is wrong version number"
        }
    }
}
IDE::CompView instproc showComponents {} {
    my instvar visibilityNoIDE
    if {$visibilityNoIDE} {
        my setList [IDE::IntroProxy getComponentsNoIDE]
    } else {
        my setList [IDE::IntroProxy getComponents]
    }
}
IDE::CompView instproc unloadComponent actual {
    set reqComp [IDE::System getCoreComponentsAll]
    if {[::ide::lcontain $reqComp $actual]} {
        IDE::Dialog message "You can not unload this IDE-System Component [list $reqComp]"
        return
    }
    set appObj [IDE::Component getCompObjectForName $actual]
    set reqFor [$appObj getRequiredFor]
    if {$reqFor ne ""} {
        IDE::Dialog message "You can not unload $actual. It is required from $reqFor"
        return
    }
    $appObj unload
    [my info parent]::classview selectFor {}
    IDE::System signalComponentsChanged
}
Class IDE::ComponentSaveWizard -superclass ::IDE::Browser
@ ::IDE::ComponentSaveWizard idemeta component IDEView
IDE::ComponentSaveWizard instproc actionSave {} {
    my instvar nometa onefile targetDir createPkgIndex
    set comps [[self]::savecomp getList]
    if {$comps eq ""} {
        IDE::Dialog message "No components to save were selected"
        return
    }
    IDE::Component saveComplex $comps $nometa $onefile $targetDir
    if {$createPkgIndex} {
        pkg_mkIndex -direct [pwd] *.xotcl
    }
    my destroy
}
IDE::ComponentSaveWizard instproc addAllToList {} {
    foreach item [[self]::complist getList] {
        my addItem $item
    }
}
IDE::ComponentSaveWizard instproc addItem item {
    if {$item eq ""} return
    [self]::savecomp addItem $item
}
IDE::ComponentSaveWizard instproc addToList {} {
    my addItem [[self]::complist selectedItem]

}
IDE::ComponentSaveWizard instproc changeDir {} {
    my instvar targetDir win
    set targetDir [IDE::Dialog getDir $targetDir]
    $win.tframe.target configure -text $targetDir
}
IDE::ComponentSaveWizard instproc createSystemMenu {} {
    # no system menu
}
IDE::ComponentSaveWizard instproc delFromList {} {
    my delItem [[self]::savecomp selectedItem]
}
IDE::ComponentSaveWizard instproc delItem item {
    if {$item ne ""} {
        [self]::savecomp removeItem $item
    }
}
IDE::ComponentSaveWizard instproc getTitle {} {
    return {Component Save Wizard}
}
IDE::ComponentSaveWizard instproc selectItem item {
    # needed because of IDE::NListView
}
IDE::ComponentSaveWizard instproc setComponentList {} {
    my instvar compVisibility
    if {!$compVisibility} {
        [self]::complist setList [IDE::IntroProxy getComponents]
    } else {
        [self]::complist setList [IDE::IntroProxy getComponentsNoIDE]
    }
}
IDE::ComponentSaveWizard instproc specificInit {} {
    my instvar win mode className parameter targetDir

    my requireNamespace
    set targetDir {}

    frame $win.buttons -relief raised -border 3
    frame $win.lframe
    frame $win.tframe

    label $win.infolabel -text "Select components to save"

    IDE::NListView [self]::complist $win.lframe.complist -notify [self] -doubleNotifyProc addItem
    IDE::NListView [self]::savecomp $win.lframe.savecomp  -notify [self] -doubleNotifyProc delItem

    my set compVisibility [IDE::System isIgnoreIDEComponents]
    checkbutton $win.lframe.visibility -text "no ide components" -variable [self]::compVisibility -command [list [self] setComponentList]

    button $win.lframe.addtolist -text < -command [list [self] addToList]
    button $win.lframe.addalltolist -text << -command [list [self] addAllToList]
    button $win.lframe.delfromlist -text del -command [list [self] delFromList]

    pack $win.lframe.visibility -side bottom -anchor e
    pack $win.lframe.savecomp -side left -expand yes -fill both
    pack $win.lframe.complist -side right -expand yes -fill both
    pack $win.lframe.addtolist -anchor s -fill x
    pack $win.lframe.addalltolist -anchor s -fill x
    pack $win.lframe.delfromlist -anchor n -fill x

    label $win.ltarget -text "Target Dir"

    label $win.tframe.target -border 2 -width 40 -relief sunken -anchor w
    button $win.tframe.change -text "Change" -command [list [self] changeDir]
    pack $win.tframe.target $win.tframe.change -side left

    checkbutton $win.nometa -text "no meta data @" -variable [self]::nometa
    checkbutton $win.onefile -text "as one file" -variable [self]::onefile
    checkbutton $win.makepkgindex -text "create pkgIndex" -variable [self]::createPkgIndex

    button $win.buttons.ok -text Save -command [list [self] actionSave]
    button $win.buttons.cancel -text "Cancel" -command [list [self] destroy]
    pack $win.buttons.ok $win.buttons.cancel -side left

    pack $win.infolabel -anchor w
    pack $win.lframe -expand 1 -fill both -pady 10
    pack $win.ltarget -anchor w
    pack $win.tframe -fill x
    pack $win.nometa $win.onefile $win.makepkgindex -anchor w
    pack $win.buttons -anchor w -ipady 10 -ipadx 6 -fill x

    [self]::savecomp setList {}
    my setComponentList
    next
}
IDE::ComponentSaveWizard proc newBrowser {} {
    return [my new [Object autoname .cswbrowser]]
}
Class IDE::ConfigurationBrowser -superclass {::IDE::Browser ::IDE::GUICommands} -parameter {{atHead 1}}
@ ::IDE::ConfigurationBrowser idemeta categories {list-manipulation initialization private user-action}
@ ::IDE::ConfigurationBrowser idemeta categoriesMethods {{downListElem upListElem addToList delFromList selectCompVersion selectComponent} {destroy fillMenuStruct getMenuStruct setComponentList specificInit} {changeViewType updateCompList} {initCompList initFromSystem loadComponents loadFromFile saveAsFile}}
@ ::IDE::ConfigurationBrowser idemeta component IDEView
IDE::ConfigurationBrowser instproc addElemToList item {
    [self]::confapp addItemAtTail $item
}
IDE::ConfigurationBrowser instproc addToList {} {
    set item [[self]::applist selectedItem]
    if {$item eq ""} return
    my addElemToList $item
}
IDE::ConfigurationBrowser instproc addUnmanagedPackage {} {
    set package [IDE::IDialogEntry getValue "Specify a tcl package that can be loaded per.\n  package require\n and is not managed by xotclide.\nWarning no syntax checking are possible!"]
    if {$package ne ""} {
        [self]::confapp addItemAtTail $package
    }
}
IDE::ConfigurationBrowser instproc changeViewType type {
    my set vtype $type
    [self]::configedit setTextControler [IDE::SystemConfigMap getValueForType $type] [self]
}
IDE::ConfigurationBrowser instproc checkRequirements {} {
    [self]::confapp unselect
    set res  [IDE::SystemConfigMap checkRequirements [[self]::confapp getList]]
    my unselectComponent
    if {$res ne ""} {
        [self]::confapp setListUnsorted $res
    }
}
IDE::ConfigurationBrowser instproc delFromList {} {
    set sitem [[self]::confapp selectedItem]
    if {$sitem ne ""} {
        [self]::confapp removeItem $sitem
    }
    my unselectComponent
}
IDE::ConfigurationBrowser instproc destroy {} {
    my updateCompList
    next
}
IDE::ConfigurationBrowser instproc downListElem {} {
    [self]::confapp reorderSelected 1
}
IDE::ConfigurationBrowser instproc editSave text {
    IDE::SystemConfigMap setValueForType [my set vtype] $text
}
IDE::ConfigurationBrowser instproc fillMenuStruct aMenuStruct {
    $aMenuStruct enablementHandler [self]
    $aMenuStruct addCommand {Load Configuration Map} [list [self] loadFromFile]
    $aMenuStruct addCommand3 {Save Configuration Map as} [list [self] saveAsFile {}] hasComponents
    $aMenuStruct addCommand {Drop Comp List Changes} [list [self] initCompList]
    $aMenuStruct addCommand {Add Unmanaged Package} [list [self] addUnmanagedPackage]
    $aMenuStruct addSeparator
    $aMenuStruct addCommand3 {Deploy as File-Collection} [list [self] saveDistribution] hasComponents
    $aMenuStruct addCommand3 {Deploy as Tclkit} [list [self] saveAsTclkit] hasComponents
    $aMenuStruct addSeparator
    $aMenuStruct addCommand {Init from System} [list [self] initFromSystem]
    $aMenuStruct addCommand3 {Load Components} [list [self] loadComponents] hasComponents
    $aMenuStruct addCommand3 {Save ConfigMap Components} [list IDE::SystemConfigMap saveConfigMapComponents] hasComponents
    $aMenuStruct addSeparator
    $aMenuStruct addCommand3 {Run Start Scripts} [list IDE::SystemConfigMap startScripts] hasComponents
}
IDE::ConfigurationBrowser instproc getMenuStruct {} {
    IDE::MenuStruct  create [self]::ms Configuration 0
}
IDE::ConfigurationBrowser instproc getTitle {} {
    return {Configuration Map Browser}
}
IDE::ConfigurationBrowser instproc hasComponents {} {
    expr {[llength [[self]::confapp getList]]>0}
}
IDE::ConfigurationBrowser instproc initCompList {} {
    set list [IDE::SystemConfigMap getValueForType componentsToLoad]
    [self]::confapp setListUnsorted  [lrange $list 0 end]
}
IDE::ConfigurationBrowser instproc initFromSystem {} {
    my instvar vtype
    IDE::SystemConfigMap initFromSystem
    my initCompList
    my changeViewType $vtype
}
IDE::ConfigurationBrowser instproc loadComponents {} {
    IDE::SystemConfigMap loadComponents
    my initCompList
}
IDE::ConfigurationBrowser instproc loadFromFile {} {
    my instvar vtype
    IDE::SystemConfigMap loadFromFile {}
    my initCompList
    my changeViewType $vtype
}
IDE::ConfigurationBrowser instproc saveAsFile args {
    my updateCompList
    IDE::SystemConfigMap saveAsFile {}
}
IDE::ConfigurationBrowser instproc saveAsTclkit {} {
    my updateCompList
    IDE::PlugInsManager loadExtras TclKitDeployer
}
IDE::ConfigurationBrowser instproc saveDistribution {} {
    my updateCompList
    IDE::SystemConfigMap saveDistribution
}
IDE::ConfigurationBrowser instproc selectCompVersion version {
    my instvar selectedCompItem
    if {$version eq "automatic"} {
        set new [lindex $selectedCompItem 0]
    } elseif {$version eq "package"} {
        set new [list [lindex $selectedCompItem 0] package]
    } else {
        set new [list [lindex $selectedCompItem 0] [lindex $version 0]]
    }
    [self]::confapp renameItemUnsorted $selectedCompItem $new
    set selectedCompItem $new
}
IDE::ConfigurationBrowser instproc selectComponent compItem {
    my instvar compVersionCash selectedCompItem
    if {![IDE::System isDatabase]} return
    set selectedCompItem $compItem
    set comp [lindex $compItem 0]

    if {![info exists compVersionCash($comp)]} {
        set compVersionCash($comp) [IDE::ComponentPersistence getVersionsForName $comp]
    }
    [self]::appversion setListUnsorted [concat automatic package $compVersionCash($comp)]
    set version [lindex $compItem 1]
    if {$version eq ""} {[self]::appversion setSelectedItem automatic 0; return}
    if {$version eq "package"} {[self]::appversion setSelectedItem package 0; return}
    set i 0
    foreach item $compVersionCash($comp) {
        if {$version==[lindex $item 0]} {
            [self]::appversion setSelectedIndex [expr {$i+2}] 0
            return
        }
        incr i
    }
}
IDE::ConfigurationBrowser instproc setComponentList {} {
    my instvar compVisibility classView
    if {!$compVisibility} {
        [self]::applist setList [IDE::IntroProxy getComponents]
    } else {
        [self]::applist setList [IDE::IntroProxy getComponentsNoIDE]
    }
}
IDE::ConfigurationBrowser instproc specificInit {} {
    my instvar win

    panedwindow $win.panedwindow -orient vertical
    frame $win.lframe
    frame $win.bframe
    frame $win.lframe.comp

    IDE::NListView [self]::confapp $win.lframe.comp.confapp -notify [self] -notifyProc selectComponent -height 1
    IDE::NListView [self]::appversion $win.lframe.comp.appversion -notify [self] -notifyProc selectCompVersion -height 3
    label $win.lframe.comp.label -text {Versions Options}
    button $win.lframe.comp.checkreq -text {Check Requirements} -command [list [self] checkRequirements]

    pack $win.lframe.comp.confapp -expand yes -fill both
    pack $win.lframe.comp.label -anchor w
    pack $win.lframe.comp.appversion -fill x
    pack $win.lframe.comp.checkreq -anchor w

    IDE::ListView [self]::applist $win.lframe.classlist

    my set compVisibility [IDE::System isIgnoreIDEComponents]
    checkbutton $win.lframe.visibility -text "no IDE components" -variable [self]::compVisibility -command [list [self] setComponentList]

    button $win.lframe.addtolist -text << -command [list [self] addToList]
    button $win.lframe.delfromlist -text del -command [list [self] delFromList]
    button $win.lframe.upitem -text up -command [list [self] upListElem]
    button $win.lframe.downitem -text down -command [list [self] downListElem]

    IDE::MethodEdit [self]::configedit $win.cedit -height 1
    IDE::TabButtons [self]::cbutton $win.cbutton  -states {preStartScript startScript} -command [list [self] changeViewType]

    pack $win.lframe.visibility -side bottom -anchor e
    pack $win.lframe.comp -side left -expand yes -fill both
    pack $win.lframe.classlist -side right -expand yes -fill both
    pack $win.lframe.addtolist -anchor s -fill x
    pack $win.lframe.delfromlist -anchor n -fill x
    pack $win.lframe.upitem -fill x
    pack $win.lframe.downitem -fill x

    pack $win.cedit -expand yes -fill both -in $win.bframe
    pack $win.cbutton -anchor w -in $win.bframe

    $win.panedwindow add $win.lframe -sticky news -height 200
    $win.panedwindow add $win.bframe -sticky news -height 200
    pack $win.panedwindow -expand yes -fill both

    [self]::cbutton setState startScript
    my changeViewType startScript

    my setComponentList
    my initCompList
    next
}
IDE::ConfigurationBrowser instproc unselectComponent {} {
    my set selectedCompItem {}
    [self]::appversion setListUnsorted {}
}
IDE::ConfigurationBrowser instproc upListElem {} {
    [self]::confapp reorderSelected -1
}
IDE::ConfigurationBrowser instproc updateCompList {} {
    IDE::SystemConfigMap setValueForType componentsToLoad [[self]::confapp getList]
}
IDE::ConfigurationBrowser proc hasView {} {
    expr  {[llength [my info instances]]!=0}
}
IDE::ConfigurationBrowser proc showBrowser {} {
    set first [lindex [my info instances] 0]
    if {$first eq ""} {
        my create confbrowser [Object autoname .browser]
    }
}
@ Class IDE::ContextEval {
description {This class is used for mixins to overwrite the string
evalution from selected text.

please init the instance variable "context" with the contex object.
All eval are do by using

$context eval $script}
}
Class IDE::ContextEval
@ ::IDE::ContextEval idemeta component IDEView
IDE::ContextEval instproc evalString string {
    [my set context] eval $string
}
Class IDE::Deployer -superclass ::IDE::Browser
@ ::IDE::Deployer idemeta component IDEView
IDE::Deployer instproc actionGenerate {} {
    my instvar targetDir nometa onefile nopackages configName
    set compToSave [my getComponentsToDeploy]
    if {[llength $compToSave]==0} return

    my prepareDirectory

    if {!$onefile} {
        foreach cobj $compToSave {
            $cobj saveAsScript [$cobj standardFileName] $nometa
        }
    }
    if {!$nopackages && !$onefile} {
        pkg_mkIndex -direct [pwd] *.xotcl
    }
    if {!$nopackages && !$onefile} {
        my writeScriptFile [file rootname [file tail $configName]].cfmap [IDE::SystemConfigMap asScript]
    }
    my writeScriptFile [my getStartscriptName] [my startScriptString $compToSave]

    my setFileAttributes
    my postGenerate
    IDE::Dialog message "Distribution $configName is generated in $targetDir. Take a look at generated files. Check if all packages are saved. Copy another stuff (tcl-scripts, etc) in this directory."
    my destroy
}
IDE::Deployer instproc changeDir {} {
    my set targetDir [IDE::Dialog getDir [my set targetDir]]
}
IDE::Deployer instproc createSystemMenu {} {
    # no system menu
}
IDE::Deployer instproc getComponentsToDeploy {} {
    set compToSave {}
    if {![IDE::SystemConfigMap exists componentsToLoad] || [IDE::SystemConfigMap set componentsToLoad] eq ""} {
        if {![IDE::ConfigurationBrowser hasView]} {
            set result [IDE::Dialog yesNo "There are currently no components in configuration map that can be deployed. Do you want to start \"Configuration Map Browser\" and specify them"]
            if {$result} {
                IDE::ConfigurationBrowser showBrowser
            }
        } else {
            IDE::Dialog message "There are currently no components in configuration map that can be deployed. Please specify the components in \"Configuration Map Browser\" first"
        }
        return [list]
    }
    foreach comp [IDE::SystemConfigMap set componentsToLoad] {
        set name [lindex $comp 0]
        set cobj [IDE::Component getCompObjectForNameIfExist $name]
        if {$cobj eq ""} {
            IDE::Dialog message "$comp is not currently loaded. You can only maka a distribution from loaded components. Operation canceled"
            cd [my set old_dir]
            return
        }
        lappend compToSave $cobj
    }
    return $compToSave
}
IDE::Deployer instproc getStartscriptName {} {
    my set configName
}
IDE::Deployer instproc getTitle {} {
    return {Application Deployer}
}
IDE::Deployer instproc postGenerate {} {
    cd [my set old_dir]
}
IDE::Deployer instproc prepareDirectory {} {
    my instvar targetDir old_dir
    if {![file isdirectory $targetDir]} {
        file mkdir $targetDir
    }
    set old_dir [pwd]
    cd $targetDir
}
IDE::Deployer instproc setFileAttributes {} {
    my instvar configName
    if {![IDE::System isWindowsPlatform]} {
        file attributes $configName -permission rwxr--r--
    }
}
IDE::Deployer instproc setIsXOTclCode {} {
    my instvar isXOTclcode
    if {![IDE::SystemConfigMap exists componentsToLoad]} {
        return
    }
    set isXOTclcode 0
    foreach comp [IDE::SystemConfigMap set componentsToLoad] {
        set name [lindex $comp 0]
        set cobj [IDE::Component getCompObjectForNameIfExist $name]
        if {$cobj ne ""} {
            if {[llength [$cobj getObjects]]>0 || [llength [$cobj getClasses]]>0} {
                set isXOTclcode 1
                break
            }
        }
    }
}
IDE::Deployer instproc specificInit {} {
    my instvar win mode className parameter targetDir configName nometa onefile isXOTclcode

    my requireNamespace
    set targetDir [pwd]
    set nometa 1
    set onefile 1
    set isXOTclcode 1

    if {![IDE::SystemConfigMap exists configName]} {
        set configName Start.tcl
    } else {
        set configName [IDE::SystemConfigMap set configName].tcl
    }

    frame $win.buttons -relief raised -border 3
    frame $win.lframe
    frame $win.sframe
    frame $win.tframe

    label $win.infolabel -text "Specify deployments options"

    label $win.ltarget -text "Target Dir"
    label $win.tframe.target -border 2 -width 40 -relief sunken -anchor w -textvariable [self]::targetDir
    button $win.tframe.change -text "Change" -command [list [self] changeDir]
    pack $win.tframe.target  -side left -fill x -expand yes
    pack $win.tframe.change -side left

    label $win.sframe.lab -text "Start File"
    entry $win.sframe.target -textvariable [self]::configName
    pack $win.sframe.lab $win.sframe.target -side left

    checkbutton $win.nometa -text "no meta data @ (metadata need XOTcl)" -variable [self]::nometa
    checkbutton $win.onefile -text "as one file" -variable [self]::onefile
    checkbutton $win.nopackages -text "no packages (use source)" -variable [self]::nopackages
    checkbutton $win.isxotclcode -text "Init XOTcl extension" -variable [self]::isXOTclcode

    button $win.buttons.ok -text Generate -command [list [self] actionGenerate]
    button $win.buttons.cancel -text Cancel -command [list [self] destroy]
    pack $win.buttons.ok $win.buttons.cancel -side left

    pack $win.infolabel -anchor w
    pack $win.ltarget -anchor w
    pack $win.tframe -anchor w -fill x
    pack $win.nometa $win.onefile $win.nopackages $win.isxotclcode -anchor w
    pack $win.sframe -anchor w
    pack $win.buttons -anchor w -ipady 10 -ipadx 6 -fill x

    next

    my setIsXOTclCode
}
IDE::Deployer instproc startScriptInvocation {} {
    my instvar onefile nopackages isXOTclcode
    set script {#!/usr/local/bin/tcl
# File generated by xotclIDE
# edit if you want
}

    if {$isXOTclcode} {
        append script {package require XOTcl
namespace import xotcl::*
}
}

    append script {# we set variable progdir to script location
set sname [info script]
if {$sname eq ""} {
    # Run interactive for develop purposes
    set progdir [pwd]
} else {
    file lstat $sname stats
    # follow sym links
    if {$stats(type) eq "link"} {
        set sname [file readlink $sname]
        if {[file pathtype $sname] eq "relative"} {
            set sname [file join [file dirname [info script]] $sname]
        }
    }
    set progdir [file dirname $sname]
}
}
   if {!$nopackages && !$onefile} {
      append script {lappend auto_path [file dirname $progdir]} \n
   }
   return $script
}
IDE::Deployer instproc startScriptString compToSave {
    my instvar onefile nopackages nometa
    if {[IDE::SystemConfigMap exists preStartScript] && [IDE::SystemConfigMap set preStartScript] ne ""} {
        append script [IDE::SystemConfigMap set preStartScript] \n
    } else {
        append script [my startScriptInvocation]
    }
    if (!$onefile) {
        if {$nopackages} {
            foreach comp $compToSave {
                append script "source [$comp standardFileName]\n"
            }
        } else {
            foreach comp [IDE::SystemConfigMap set componentsToLoad] {
                append script "package require [lindex $comp 0]\n"
            }
        }
    } else {
        foreach comp $compToSave {
            append script [$comp asScript $nometa] \n
        }
    }
    if {[IDE::SystemConfigMap exists startScript]} {
        append script [IDE::SystemConfigMap set startScript] \n
    }
    return $script
}
IDE::Deployer instproc writeScriptFile {name value} {
    set f [open $name w]
    puts -nonewline $f $value
    close $f
}
IDE::Deployer proc newBrowser {} {
    my instvar browser
    if {![info exists browser] || ![Object isobject $browser]} {
        set browser [my new [Object autoname .deployer]]
    } else {
        IDE::Dialog message "Deployer browser is already open"
    }
}
Class IDE::EditorTranscript -superclass ::IDE::Editor
@ ::IDE::EditorTranscript idemeta component IDEView
IDE::EditorTranscript instproc changeStdOutTie {} {
    my instvar stdOutTie
    if {$stdOutTie} {
        trace add execution puts enter ide::putsTrace
    } else {
        trace remove execution puts enter ide::putsTrace
    }
}
IDE::EditorTranscript instproc fileIn {} {
    next
    my instvar fileName
    if {[info exists fileName]} {
        [my info parent] setTitleAddition $fileName
    }
}
IDE::EditorTranscript instproc fileNew {} {
    my instvar fileName
    unset fileName
    my setText {}
}
IDE::EditorTranscript instproc fileOut {} {
    next
    my instvar fileName
    if {[info exists fileName]} {
        [my info parent] setTitleAddition $fileName
    }
}
IDE::EditorTranscript instproc fileSave {} {
    my instvar fileName
    if {![info exists fileName]} {
        my fileOut
    } else {
        my saveFile $fileName
    }
}
IDE::EditorTranscript instproc fillMenuStruct ms {
    $ms enablementHandler [self]
    $ms addCommand {New} [list [self] fileNew] 0 Control-s
    $ms addCommand {Open File} [list [self] fileIn] 0 Control-o
    $ms addCommand {Append File} [list [self] fileAppend] 0 Control-p
    $ms addCommand {Save File} [list [self] fileSave] 0 Control-s
    $ms addCommand {Save File As} [list [self] fileOut] 5
    $ms addSeparator
    $ms addMenuItem [IDE::MenuCommand new -childof $ms -accelerator Alt-q -name {Do it} -command [list [self] evalSelection] -popdownMenu 1 -enableList isValidTextSelection]
    $ms addMenuItem [IDE::MenuCommand new -childof $ms -accelerator Control-q -name {Print it} -command [list [self] evalDisplaySelection] -popdownMenu 1 -enableList isValidTextSelection]
    $ms addMenuItem [IDE::MenuCommand new -childof $ms -accelerator Alt-x -name {Substitute it} -command [list [self] evalSubstituteSelection] -popdownMenu 1 -enableList isValidTextSelection]
    $ms addMenuItem [IDE::MenuCommand new -childof $ms -accelerator Control-g -name {Inspect it} -command [list [self] evalInspectSelection] -popdownMenu 1 -enableList isValidTextSelection]
    $ms addMenuItem [IDE::MenuCommand new -childof $ms -accelerator Control-r -name {Browse it} -command [list [self] browseSelection] -popdownMenu 1 -enableList isValidTextSelection]
    $ms addMenuItem [::IDE::MenuCommand new -childof $ms -name Find/Replace -command [list IDE::FindReplace bindToView [self]] -popdownMenu 1 -accelerator Alt-f]
    if {[my info parent] eq "::transcript"} {
        my set stdOutTie 0
        $ms addCheckButton "Forward 'puts' outputs" [self]::stdOutTie [list [self] changeStdOutTie]
    }
}
Class IDE::GlobalVarsInspector -superclass ::IDE::Browser
@ ::IDE::GlobalVarsInspector idemeta component IDEView
IDE::GlobalVarsInspector instproc getTitle {} {
    return "Global Variable Inspector"
}
IDE::GlobalVarsInspector instproc setVarValue {value controller} {
    [self]::varvalue setTextControler $value $controller
}
IDE::GlobalVarsInspector instproc specificInit {} {
    my instvar win

    if {[IDE::System isTkNeverThan84]} {
        panedwindow $win.panedwindow -orient vertical
        IDE::GlobalVarsView [self]::varslist $win.varslist -height 2
        IDE::MethodEdit [self]::varvalue $win.varvalue -width 70 -height 20
        $win.panedwindow add $win.varslist -sticky news -height 180
        $win.panedwindow add $win.varvalue -sticky news -height 200
        pack $win.panedwindow -expand yes -fill both
    } else {
        grid $win.varslist -column 0 -row 0 -sticky news
        grid $win.varvalue -column 0 -row 1 -sticky news
        grid rowconfigure $win 0 -weight 1
        grid rowconfigure $win 1 -weight 2
        grid columnconfigure $win 0 -weight 1
    }
    my initStatusBar 2 2
    [self]::varslist refresh
}
IDE::GlobalVarsInspector proc startBrowser {} {
    my new [Object autoname .importview]
}
@ Class IDE::VarsView {
description {The parent object must understand the messages

[my info parent] setVarValue $value [self]
[my info parent] setStatusBarText $message}
}
Class IDE::VarsView -superclass {::IDE::ListView ::IDE::GUICommands} -parameter {{label {Object Vars}} {hasLock 0}}
@ ::IDE::VarsView idemeta categories {user-actions initialize}
@ ::IDE::VarsView idemeta categoriesMethods {{unsetVariable inspectAsObject inspectAsObjectsList} {getMenuStruct fillMenuStruct}}
@ ::IDE::VarsView idemeta component IDEView
IDE::VarsView instproc addToReadTrace actual {
    my instvar vobject vtype
    $vobject requireNamespace
    IDE::VarsTracker addTrace ${vobject}::${actual} read
}
IDE::VarsView instproc addToWatch actual {
    my instvar vobject vtype
    $vobject requireNamespace
    IDE::VarsTracker addTrace ${vobject}::${actual} watch
}
IDE::VarsView instproc addToWriteTrace actual {
    my instvar vobject vtype
    $vobject requireNamespace
    IDE::VarsTracker addTrace ${vobject}::${actual} write
}
IDE::VarsView instproc askForItemChange {} {
    if {[Object isobject [my info parent]::methodedit]} {
        [my info parent]::methodedit askForModification
    } else {
        return 1
    }
}
IDE::VarsView instproc buttonPush {} {
    next
    my set lock 0
}
IDE::VarsView instproc editSave value {
    my instvar vvariable vtype vobject
    if {$vtype eq "array"} {
        my varAction array set $vvariable $value
    } else {
        my varAction set $vvariable $value
    }
}
IDE::VarsView instproc fillMenuStruct ms {
    $ms enablementHandler [self]
    $ms addCommand2 {Inspect as Object} [list [self] dispatchWithSelected inspectAsObject] isValidSelection
    $ms addCommand2 {Inspect as Objects List} [list [self] dispatchWithSelected inspectAsObjectsList] isValidSelection
    $ms addCommand2 {Inspect Array} [list [self] dispatchWithSelected inspectArray] {isValidSelection isSelectionArray}
    $ms addCommand2 {Search References} [list [self] dispatchWithSelected searchReferences] isValidSelection
    $ms addSeparator
    $ms addCommand2 {Debug on Read Access} [list [self] dispatchWithSelected addToReadTrace] {isValidSelection isNotSelectionArray}
    $ms addCommand2 {Debug on Write Access} [list [self] dispatchWithSelected addToWriteTrace] {isValidSelection isNotSelectionArray}
    $ms addCommand2 {Watch Variable} [list [self] dispatchWithSelected addToWatch] {isValidSelection isNotSelectionArray}
    $ms addSeparator
    $ms addCommand2 {Unset Variable} [list [self] dispatchWithSelected unsetVariable] isValidSelection
    $ms addCommand2 {Refresh} [list [self] refresh] hasObject
    next
}
IDE::VarsView instproc getMenuStruct {} {
    IDE::MenuStruct [self]::ms Variables 0
}
IDE::VarsView instproc hasObject {} {
    expr {[my set vobject] ne ""}
}
IDE::VarsView instproc init window {
    my instvar win
    next
    if {[my hasLock]} {
        my requireNamespace
        frame $win.labframe
        checkbutton $win.lock -text lock -variable [self]::lock -command [list [self] lockStateChange]
        raise $win.label
        pack forget $win.label
        pack $win.label -side left -in $win.labframe -anchor w
        pack $win.lock -side right -in $win.labframe -anchor e
        pack $win.labframe -anchor e -side top -before $win.listbox -fill x
    }
}
IDE::VarsView instproc inspectArray actual {
    my instvar vobject vtype
    if {$vtype ne "array"} {
        IDE::Dialog error "You must select an array"
        return
    }
    IDE::ArrayBrowser inspectArray $vobject $actual
}
IDE::VarsView instproc inspectAsObject actual {
    my instvar vobject vtype
    if {$vtype eq "array"} return
    set value [my varAction set $actual]
    if {![Object isobject $value]} {
        IDE::Dialog message "$value is not an Object"
        return
    }
    $value inspect
}
IDE::VarsView instproc inspectAsObjectsList actual {
    my instvar vobject vtype
    if {$vtype eq "array"} {
        set value {}
        for {set sid [my varAction array startsearch $actual]} {[my varAction array anymore $actual $sid]} {} {lappend value [my varAction set ${actual}([my varAction array nextelement $actual $sid])]}
        my varAction array donesearch $actual $sid
    } else {
        set value [my varAction set $actual]
    }
    set objects {}
    foreach obj $value {
        if {[Object isobject $obj]} {
            lappend objects $obj
        }
    }
    if {[llength $objects]>0} {
        IDE::ObjectBrowser browseObjectsList $objects
    } else {
        IDE::Dialog message "There are no objects in the list"
    }
}
IDE::VarsView instproc isLockOn {} {
    expr {[my hasLock] && [my set lock]}
}
IDE::VarsView instproc isNotSelectionArray {} {
    expr {[my set vtype] ne "array"}
}
IDE::VarsView instproc isSelectionArray {} {
    expr {[my set vtype] eq "array"}
}
IDE::VarsView instproc lockStateChange {} {
    my instvar selectedIndex listItems
    if {[my isLockOn]} {
        my set lockedValue [lindex $listItems $selectedIndex]
    }
}
IDE::VarsView instproc refresh {} {
    my instvar vobject
    my setList [$vobject info vars]
    my selectItem {}
}
IDE::VarsView instproc searchReferences actual {
    my instvar vobject vtype
    if {[$vobject info class] eq "::Object"} {
       set sclass $vobject
    } else {
       set sclass [$vobject info class]
    }
    IDE::MethodBrowser searchTextClass $actual $sclass
}
IDE::VarsView instproc selectFor object {
    my instvar vobject lockedValue listItems
    set vobject $object
    if {$object eq ""} {
        my resetList
        return 0
    }
    my setList [$object info vars]
    if {[my isLockOn]} {
        my setSelectedItem $lockedValue
        return 1
    } else {
        my selectItem {}
        return 0
    }
}
IDE::VarsView instproc selectItem var {
    my instvar vobject vtype vvariable
    if {$var eq ""} return
    set message "variable $var"
    set vvariable $var
    if {[my varAction array exists $var]} {
        set value [my varAction array get $var]
        set message "array $var"
        set vtype array
    } elseif {[my varAction info exists $var]} {
        set value [my varAction set $var]
        if {[Object isobject $value]} {
            set value "$value\n[$value printString]"
            set vtype object
        } else {
            set vtype string
        }
    } else {
        set value UNKNOWN
        set vtype UNKNOWN
    }
    [my info parent] setVarValue $value [self]
    [my info parent] setStatusBarText $message
}
IDE::VarsView instproc unsetVariable actual {
    my varAction unset $actual
    my refresh
}
IDE::VarsView instproc varAction args {
    [my set vobject] eval $args
}
Class IDE::GlobalVarsView -superclass ::IDE::VarsView -parameter {{label {Global Vars}}}
@ ::IDE::GlobalVarsView idemeta component IDEView
IDE::GlobalVarsView instproc addToReadTrace actual {
    if {[string range $actual 0 1] ne "::"} {
        set variable ::$actual
    } else {
        set variable $actual
    }
    IDE::VarsTracker addTrace $variable read
}
IDE::GlobalVarsView instproc addToWatch actual {
    if {[string range $actual 0 1] ne "::"} {
        set variable ::$actual
    } else {
        set variable $actual
    }
    IDE::VarsTracker addTrace $variable watch
}
IDE::GlobalVarsView instproc addToWriteTrace actual {
    if {[string range $actual 0 1] ne "::"} {
        set variable ::$actual
    } else {
        set variable $actual
    }
    IDE::VarsTracker addTrace $variable
}
IDE::GlobalVarsView instproc getVariablesInNamespace namespace {
    if {$namespace eq "::xotcl"} return
    set res [namespace eval $namespace ::info vars]
    ide::lremoveAll res [info globals]
    set res [ide::lcollect each $res {namespace eval $namespace [list namespace which -variable $each]}]
    foreach chns [namespace children $namespace] {
        if {[Object isobject $chns]} continue
        set res [concat $res [my getVariablesInNamespace $chns]]
    }
    return $res
}
IDE::GlobalVarsView instproc hasObject {} {
    return 1
}
IDE::GlobalVarsView instproc init window {
    next
    my instvar win
    my set treeView 0
    frame $win.fframe
    label $win.fframe.lfilter -text Filter
    entry $win.fframe.efilter
    $win.fframe.efilter insert 0 *
    button $win.fframe.filter -text Refresh -command [list [self] refresh]
    pack $win.fframe.lfilter $win.fframe.efilter $win.fframe.filter -side left
    pack $win.fframe -anchor w
    bind $win.fframe.efilter <Return> [list [self] refresh]
}
IDE::GlobalVarsView instproc inspectArray actual {
    my instvar vtype
    if {$vtype ne "array"} {
        IDE::Dialog error "You must select an array"
        return
    }
    IDE::ArrayBrowser inspectGlobalArray $actual
}
IDE::GlobalVarsView instproc refresh {} {
    my instvar win
    set varList [lsort -unique [concat [my getVariablesInNamespace ::] [info globals]]]
    set filter [$win.fframe.efilter get]
    if {$filter ne "*" || $filter ne ""} {
        set varList [ide::lselect each $varList {[string match $filter $each]}]
    }
    my setList $varList
}
IDE::GlobalVarsView instproc selectFor object {
    error "unproper use. Heritage is dirty"
}
IDE::GlobalVarsView instproc varAction args {
    namespace eval :: $args
}
Class IDE::HeritageBrowser -superclass ::IDE::Browser -parameter {{vtype heritage}}
@ ::IDE::HeritageBrowser idemeta component IDEView
IDE::HeritageBrowser instproc browse class {
    [self]::hclassview selectFor $class
    my setTitleAddition $class
}
IDE::HeritageBrowser instproc closeWindow {} {
    if {[[self]::methodedit askForModification]} {
        next
    }
}
IDE::HeritageBrowser instproc getTitle {} {
    my instvar vtype
    if {$vtype eq "heritage"} {
        return {Heritage Browser}
    } else {
        return {Children Browser}
    }
}
IDE::HeritageBrowser instproc initStatusBarWin win {
    my instvar statusBarTextWin
    frame $win
    label $win.label -anchor w
    set statusBarTextWin $win.label
    IDE::StateButtonActivity [self]::stateButton $win.stateBut -states {Source Comment} -command [list [self]::methodedit changeViewType]
    bind [winfo toplevel $win] <Alt-u> [list $win.stateBut invoke]
    pack $win.label  -side left
    pack $win.stateBut -side right
}
IDE::HeritageBrowser instproc specificInit {} {
    my instvar win vtype

    # The simplest factory pattern case in the free world
    if {[IDE::System isDatabase]} {
        set postFix DB
    } else {
        set postFix ""
    }
    panedwindow $win.panedwindow -orient vertical
    panedwindow $win.upperarea -orient horizontal
    IDE::HeritageClassView [self]::hclassview $win.upperarea.hclassview -vtype $vtype -focusKey {Alt-KeyPress-1} -height 1
    IDE::MethodCategoryView [self]::methodcatview $win.upperarea.methodcatview  -focusKey {Alt-KeyPress-2}  -height 1
    IDE::MethodView${postFix} [self]::methodview $win.upperarea.methodview  -focusKey {Alt-KeyPress-3}  -height 1
    IDE::TclModeEdit [self]::methodedit $win.methodedit

    $win.upperarea add $win.upperarea.hclassview $win.upperarea.methodcatview $win.upperarea.methodview -width 200
    $win.panedwindow add $win.upperarea  $win.methodedit -sticky news -height  220
    pack $win.panedwindow -expand yes -fill both

    my initStatusBar 2 3
}
IDE::HeritageBrowser proc newBrowser {{tclass {}}} {
    set class $tclass
    if {$class eq ""} {
        set class [IDE::ClassSelector getClass]
        if {$class eq ""} return
    }
    set newinst [my new [Object autoname .heritagebrowser]]
    $newinst browse $class
    return $newinst
}
IDE::HeritageBrowser proc newBrowserChild {{tclass {}}} {
    set class $tclass
    if {$class eq ""} {
        set class [IDE::ClassSelector getClass]
        if {$class eq ""} return
    }
    set newinst [my create [Object autoname browser] [Object autoname .browser] -vtype children]
    $newinst browse $class
    return $newinst
}
Class IDE::HeritageClassView -superclass {::IDE::AbstractClassView ::IDE::GUICommands ::IDE::FocusPerKey} -parameter {{label Classes} {vtype heritage}}
@ ::IDE::HeritageClassView idemeta categories user_actions
@ ::IDE::HeritageClassView idemeta categoriesMethods refresh
@ ::IDE::HeritageClassView idemeta component IDEView
IDE::HeritageClassView instproc editSave skript {
    IDE::Dialog message {View can not be used for saving}
}
IDE::HeritageClassView instproc editSaveComment comment {
    my instvar actItem
    if {[Object isobject $actItem]} {
        $actItem setComment $comment
    }
}
IDE::HeritageClassView instproc fillMenuStruct ms {
    next
    $ms addCommand Refresh [list [self] refresh]
}
IDE::HeritageClassView instproc getMenuStruct {} {
    IDE::MenuStruct create [self]::ms Class
}
IDE::HeritageClassView instproc refresh {} {
    my instvar vclass
    my selectFor $vclass
}
IDE::HeritageClassView instproc refreshView {} {
    my instvar actItem
    set v [my info parent]::methodedit
    if {[$v set vtype] eq "Comment"} {
        set comment [$actItem getComment]
        [my info parent]::methodedit setTextControler $comment [self]
        [my info parent]::stateButton setActivity 0
    } elseif {[$v set vtype] eq "Source"} {
        [my info parent]::methodedit setTextControler [IDE::IntroProxy getObjDef $actItem] [self]
        set hasComment [$actItem hasComment]
        set sb [my info parent]::stateButton
        $sb setActivity $hasComment
    }
}
IDE::HeritageClassView instproc selectFor class {
    my instvar hlist vclass vtype
    if {$vtype eq "heritage"} {
       my setHList [list [$class getHeritage]]
    } elseif {$vtype eq "children"} {
       my setHList [list [$class getChildrenHierarchy]]
    }
    set vclass $class
}
IDE::HeritageClassView instproc selectItem tclass {
    set class [string trimleft $tclass]
    if {[Object isobject [my info parent]::methodcatview]} {
        [my info parent]::methodcatview selectFor $class Classes
    }
    if {$class eq ""} return
    my set actItem $class
    my refreshView
}
Class IDE::ImportMethodView -superclass ::IDE::Browser -parameter component
@ ::IDE::ImportMethodView idemeta component IDEView
IDE::ImportMethodView instproc createSystemMenu {} {
  # no system menu
}
IDE::ImportMethodView instproc getTitle {} {
    return "Tcl Procs Import"
}
IDE::ImportMethodView instproc importMethods {} {
    foreach method [[self]::methodlist selectedItem] {
        [my component] importTclProc $method
    }
    my useFilter
}
IDE::ImportMethodView instproc specificInit {} {
    my instvar win hideTclTk

    my requireNamespace
    set hideTclTk 1

    message $win.info -text "With with tool you can import tcl procedures known by interpreter but not registered in XOTclIDE. It can be used by starting XOTclIDE form foreign applicaiton or executing tcl scripts that create procs" -width 450

    IDE::ListView [self]::methodlist $win.mlist -multiselect 1
    entry $win.efilter
    $win.efilter insert 0 *
    button $win.usefilter -text "Use Filter" -command [list [self] useFilter]
    button $win.import -text "Import" -command [list [self] importMethods]
    checkbutton $win.hideTclTk -text "Hide tcl-tk core" -variable [self]::hideTclTk

    grid $win.info -column 0 -row 0
    grid $win.mlist -column 0 -row 1 -columnspan 2 -sticky news
    grid $win.efilter -column 0 -row 2 -sticky w
    grid $win.usefilter -column 1 -row 2 -sticky w
    grid $win.hideTclTk -column 0 -row 3 -sticky w
    grid $win.import -column 0 -row 4 -sticky w
    grid rowconfigure $win 0 -weight 1
    grid columnconfigure $win 0 -weight 1

    my useFilter
}
IDE::ImportMethodView instproc useFilter {} {
    my instvar win hideTclTk
    set filter [$win.efilter get]
    set methods [IDE::TclProcsDescription getAllUnRegisteredMethods]
    if {$filter ne "*"} {
        set methods [ide::lselect each $methods {[string match $filter $each]}]
    }
    if {$hideTclTk} {
        foreach pattern {::auto_* ::pkg_* ::tcl* ::tk*} {
            set methods [ide::lselect each $methods {![string match $pattern $each]}]
        }
        ide::lremoveAll methods {bgerror unknown}
    }
    [self]::methodlist setList [lsort -unique $methods]
}
IDE::ImportMethodView proc startBrowserForComponent component {
    my new [Object autoname .importview] -component $component
}
@ Class IDE::MethodBrowser {
description {Method Prowser implements View for all tcl/xotcl Methods
It is used as result view for several method based search function.

The search functions are implemented as class methods}
}
Class IDE::MethodBrowser -superclass ::IDE::Browser
@ ::IDE::MethodBrowser idemeta categoriesMethodsProcs {{emptySearchResult unknown newBrowser newBrowserList} {searchTextClass searchImplementorsClass searchImplementorsComponent searchSendersAll searchTextAll searchTextComponent searchImplementorsAll} {obsoleteMatchList searchAndConvertObsoleteSelfCall searchObsoleteCall} searchImplementorsDialog}
@ ::IDE::MethodBrowser idemeta categoriesProcs {private api obsolete actions}
@ ::IDE::MethodBrowser idemeta component IDEView
IDE::MethodBrowser instproc closeWindow {} {
    if {[[self]::methodedit askForModification]} {
        next
    }
}
IDE::MethodBrowser instproc colorizeSearchString {} {
    my instvar regexpr_string
    if {[info exists regexpr_string] && $regexpr_string ne ""} {
        [self]::methodedit colorizeRegExprTextAll $regexpr_string
    }
}
IDE::MethodBrowser instproc initStatusBarWin win {
    my instvar statusBarTextWin
    frame $win
    label $win.label -anchor w
    set statusBarTextWin $win.label
    IDE::StateButtonActivity [self]::stateButton $win.stateBut -states {Source Comment} -command [list [self]::methodedit changeViewType]
    bind [winfo toplevel $win] <Alt-u> [list $win.stateBut invoke]
    pack $win.label  -side left
    pack $win.stateBut -side right
}
IDE::MethodBrowser instproc setMethodList list {
    [self]::methodlist setList $list
    if {[llength $list]>=1} {
        [self]::methodlist setSelectedIndex 0 1
    }
}
IDE::MethodBrowser instproc setSearchString re_string {
    my instvar regexpr_string
    set regexpr_string $re_string
}
IDE::MethodBrowser instproc specificInit {} {
    my instvar win

    if {[IDE::System isDatabase]} {
       set postFix DB
    } else {
       set postFix ""
    }

    panedwindow $win.panedwindow -orient vertical
    IDE::MethodListView${postFix} [self]::methodlist $win.methodlist
    IDE::TclModeEdit [self]::methodedit $win.methodedit -mixin IDE::CodeController
    $win.panedwindow add $win.methodlist -sticky news -height 130
    $win.panedwindow add $win.methodedit -sticky news -height 250
    pack $win.panedwindow -expand yes -fill both
    my initStatusBar 2 1
    next
}
IDE::MethodBrowser proc checkRegExprWithDialog text {
    if {[catch [list regexp $text sample] ret]} {
        global errorInfo
        IDE::Dialog message "The \"$text\" can not be compiled as regular expresion. Please mask all special characters \[\]\"\.\?().\n Original messege:\n\n$ret"
        return 0
    }
    return 1
}
IDE::MethodBrowser proc emptySearchResult {} {
    IDE::Dialog message {no search result}
}
IDE::MethodBrowser proc newBrowser {} {
    return [my new [Object autoname .methodbrowser]]
}
IDE::MethodBrowser proc newBrowserList {list title} {
    set inst [my newBrowser]
    $inst setMethodList $list
    $inst setTitleAddition $title
    return $inst
}
IDE::MethodBrowser proc obsoleteMatchList {text mlist} {
    foreach item $mlist {
        set expr "(?n)^\s*$item\[\[:>:\]\]"
        if {[regexp $expr $text]} {return 1}
    }
    return 0
}
IDE::MethodBrowser proc searchAndConvertObsoleteSelfCall {} {
    foreach comp [IDE::Component getComponentNames] {
        if {$comp eq "core" || $comp eq "default"} continue
        if {![string match xdobry::* $comp]} continue
        set cobj [IDE::Component getCompObjectForName $comp]
        foreach class [$cobj getClasses] {
            foreach m [$class info instprocs] {
                set body [$class info instbody $m]
                regsub -all -line {^(\s*)\[self\] } $body {\1my } body2
                # add variables (body2)
                regsub -all -line {\[\[self\] } $body2 {[my } body2
                if {$body!=$body2} {
                    set nb [lreplace [IDE::IntroProxy getBodyInstanceMethod $class $m] 4 4 $body2]
                    namespace eval :: $nb
                }
            }
        }
        foreach object [concat [$cobj getObjects] [$cobj getClasses]] {
        foreach m [$object info procs] {
            set body [$object info body $m]
                regsub -all -line {^(\s*)\[self\] } $body {\1my } body2
                regsub -all -line {\[\[self\] } $body2 {[my } body2
                if {$body!=$body2} {
                    set nb [lreplace [IDE::IntroProxy getBodyClassMethod $object $m] 4 4 $body2]
                    namespace eval :: $nb
                }
            }
        }
    }
}
IDE::MethodBrowser proc searchBreakPoints {} {
    my searchTextAll {([^#]\[self\]|my) halt}
}
IDE::MethodBrowser proc searchClassUsage class {
    if { [string range $class 0 1] == "::" } {
        # remove global namespace prefix which is not always used
        set class [string range $class 2 end]
    }
    my searchTextAll "$class\[\[:>:\]\]"
}
IDE::MethodBrowser proc searchImplementorsAll {implementor {nocomplain 0}} {
    set list {}
    if {[info procs $implementor] ne ""} {
        lappend list "proc $implementor"
    }
    if {[info procs ::$implementor] ne ""} {
        lappend list "proc $implementor"
    }
    foreach obj [IDE::IntroProxy getObjects] {
        if {[$obj info procs $implementor] ne ""} {
            lappend list "$obj class>$implementor"
        }
    }
    foreach obj [IDE::IntroProxy getClasses] {
        if {[$obj info procs $implementor] ne ""} {
            lappend list "$obj class>$implementor"
        }
        if {[$obj info instprocs $implementor] ne ""} {
            lappend list "$obj>$implementor"
        }
    }
    if {$list!={}} {
        my newBrowserList $list $implementor
    } else {
        if {!$nocomplain} {
            my emptySearchResult
        } else {
            return 0
        }
    }
    return 1
}
IDE::MethodBrowser proc searchImplementorsClass {implementor class} {
    set list {}
    if {[Object isclass $class]} {
        foreach obj [concat $class [$class info heritage] [$class getDeepChildren]] {
            if {[$obj info procs $implementor] ne ""} {
                lappend list "$obj class>$implementor"
            }
            if {[$obj info instprocs $implementor] ne ""} {
                lappend list "$obj>$implementor"
            }
        }
    }

    if {$list!={}} {
        my newBrowserList $list $implementor
    } else {
        my emptySearchResult
    }
}
IDE::MethodBrowser proc searchImplementorsComponent {implementor component} {
    set list {}
    set cobj [IDE::Component getCompObjectForNameIfExist $component]
    if {$cobj eq ""} return
    foreach obj [$cobj getObjects] {
        if {[$obj info procs $implementor] ne ""} {
            lappend list "$obj class>$implementor"
        }
    }
    foreach obj [$cobj getClasses] {
        if {[$obj info procs $implementor] ne ""} {
            lappend list "$obj class>$implementor"
        }
        if {[$obj info instprocs $implementor] ne ""} {
            lappend list "$obj>$implementor"
        }
    }
    if {$list!={}} {
        my newBrowserList $list $implementor
    } else {
        my emptySearchResult
    }
}
IDE::MethodBrowser proc searchImplementorsDialog {} {
    set ret [IDE::MethodSelector getMethod]
    if {$ret eq ""} return
    my searchImplementorsAll $ret
}
IDE::MethodBrowser proc searchObsoleteCall {} {
    set mlist {}
    foreach class [::IDE::IntroProxy getClasses]  {
        if {[string match *IDE* $class]} continue
        set mlist [concat $mlist [$class info instprocs] [$class info procs]]
    }
    foreach class [::IDE::IntroProxy getObjects]  {
        if {[string match *IDE* $class]} continue
        set mlist [concat $mlist [$class info procs]]
    }
    set list {}
    set nlist [lsort -unique $mlist]
    set mlist {}
    foreach method $nlist {
        if {[ide::lcontain [concat [Object info instprocs] info self list next lindex lrange llength] $method]} continue
            lappend mlist $method
        }

    foreach obj [Object info instances] {
        if {[string match *IDE* $obj]} continue
        foreach proc [$obj info procs] {
            if {[my obsoleteMatchList [$obj info body $proc] $mlist]} {
                lappend list "$obj class>$proc"
            }
        }
    }
    foreach obj [Class info instances] {
        if {[string match *IDE* $obj]} continue
        foreach proc [$obj info procs] {
            if {[my obsoleteMatchList [$obj info body $proc] $mlist]} {
                lappend list "$obj class>$proc"
            }
         }
         foreach iproc [$obj info instprocs] {
             if {[my obsoleteMatchList [$obj info instbody $iproc] $mlist]} {
                 lappend list "$obj>$iproc"
             }
         }
    }
    if {$list!={}} {
        set obj [my newBrowserList $list [string range $text 0 15]]
        $obj setSearchString $text
    } else {
        my emptySearchResult
    }
}
IDE::MethodBrowser proc searchSendersAll method {
    my searchTextAll \[\[:<:\]\]${method}\[\[:>:\]\] $method
}
IDE::MethodBrowser proc searchTextAll {text {title {}}} {
    if { $title == {} } {
        set title $text
    }
    set list {}
    if {![my checkRegExprWithDialog $text]} return
    # search in registered/managed tcl procs
    foreach proc [IDE::TclProcsDescription getAllRegisteredMethods] {
        if {[regexp -- $text [info body ::$proc]]} {
            lappend list "proc $proc"
        }
    }
    foreach obj [IDE::IntroProxy getObjects] {
        foreach proc [$obj info procs] {
            if {[regexp -- $text [$obj info body $proc]]} {
                lappend list "$obj class>$proc"
            }
        }
    }
    foreach obj [IDE::IntroProxy getClasses] {
        foreach proc [$obj info procs] {
            if {[regexp -- $text [$obj info body $proc]]} {
                lappend list "$obj class>$proc"
            }
        }
        foreach iproc [$obj info instprocs] {
            if {[regexp -- $text [$obj info instbody $iproc]]} {
                lappend list "$obj>$iproc"
            }
        }
    }
    if {$list!={}} {
        set obj [my newBrowserList $list [string range $title 0 15]]
        $obj setSearchString $text
    } else {
        my emptySearchResult
    }
}
IDE::MethodBrowser proc searchTextClass {text class {title {}}} {
    if { $title == {} } {
        set title $text
    }
    set list {}
    if {![my checkRegExprWithDialog $text]} return
    foreach proc [$class info procs] {
        if {[regexp -- $text [$class info body $proc]]} {
            lappend list "$class class>$proc"
        }
    }
    if {[Object isclass $class]} {
        foreach iproc [$class info instprocs] {
            if {[regexp -- $text [$class info instbody $iproc]]} {
                lappend list "$class>$iproc"
            }
        }
    }
    if {$list!={}} {
        set obj [my newBrowserList $list [string range $title 0 15]]
        $obj setSearchString $text
    } else {
        my emptySearchResult
    }
}
IDE::MethodBrowser proc searchTextComponent {text component {title {}}} {
    if { $title == {} } {
        set title $text
    }
    set list {}
    if {![my checkRegExprWithDialog $text]} return
    set cobj [IDE::Component getCompObjectForNameIfExist $component]
    if {$cobj eq ""} return
    foreach pobj [$cobj getProcsGroupsObjects] {
        foreach proc [$pobj getProcsNames] {
            if {[regexp -- $text [info body ::$proc]]} {
                lappend list "proc $proc"
            }
        }
    }
    foreach obj [$cobj getObjects] {
        foreach proc [$obj info procs] {
            if {[regexp -- $text [$obj info body $proc]]} {
                lappend list "$obj class>$proc"
            }
        }
    }
    foreach obj [$cobj getClasses] {
        foreach proc [$obj info procs] {
            if {[regexp -- $text [$obj info body $proc]]} {
                lappend list "$obj class>$proc"
            }
        }
        foreach iproc [$obj info instprocs] {
            if {[regexp -- $text [$obj info instbody $iproc]]} {
                lappend list "$obj>$iproc"
            }
        }
    }
    if {$list!={}} {
        my newBrowserList $list [string range $title 0 15]
    } else {
        my emptySearchResult
    }
}
IDE::MethodBrowser proc unknown args {
    error "unknown method on [self] $args"
}
Class IDE::MethodCategoryView -superclass {::IDE::ListView ::IDE::GUICommands ::IDE::FocusPerKey} -parameter {{label Categories}}
@ ::IDE::MethodCategoryView idemeta categories {initialize user_actions}
@ ::IDE::MethodCategoryView idemeta categoriesMethods {{getMenuStruct fillMenuStruct init} {renameCategory newCategory deleteCategory}}
@ ::IDE::MethodCategoryView idemeta component IDEView
IDE::MethodCategoryView instproc changeViewType vtype {
    my instvar vclass vobjtype viewtype
    if {$vobjtype eq "Procs"} return
    set viewtype $vtype
    my selectFor $vclass $vobjtype
}
IDE::MethodCategoryView instproc deleteCategory actual {
    my instvar viewtype vclass
    if {$viewtype eq "Instance"} {
        regexp {(.+) \([0-9]+\)} $actual _ c
        $vclass deleteCategory $c
    } elseif {$viewtype eq "Class"} {
        regexp {(.+) \([0-9]+\)} $actual _ c
        $vclass deleteCategoryB $c
    }
    my refreshView
}
IDE::MethodCategoryView instproc fillMenuStruct ms {
    $ms enablementHandler [self]
    $ms enableList isValidContext

    $ms addCheckButton {All by default} [self]::selectAllByDefault {}
    $ms addCommand2 New [list [self] newCategory]
    $ms addCommand2 Rename [list [self] dispatchWithSelected renameCategory] {isValidSelection}
    $ms addCommand2 Delete [list [self] dispatchWithSelected deleteCategory] {isValidSelection}
    next
}
IDE::MethodCategoryView instproc getMenuStruct {} {
    IDE::MenuStruct create [self]::ms Category 2
}
IDE::MethodCategoryView instproc init args {
    my instvar vclass win viewtype vobjtype selectAllByDefault
    next
    ::IDE::TabButtons [self]::stateButton $win.stateBut -states {Instance Class} -command [list [self] changeViewType]
    pack $win.stateBut -anchor w
    set vclass {}
    set vobjtype Instances
    set viewtype Instance
    set selectAllByDefault 1
}
IDE::MethodCategoryView instproc isValidContext {} {
    expr {[my exists vclass] && [my set vclass] ne ""}
}
IDE::MethodCategoryView instproc newCategory {} {
    my instvar viewtype vclass
    set newname [IDE::IDialogEntry getValue {enter new category name. Consider you can create and assign method to new category in one step. Menu Method->move to category}]
    if {$newname eq ""} return
    if {[ide::lcontain [my getList] $newname]} {
        IDE::Dialog message "Category $newname already exists!"
        return
    }
    if {$viewtype eq "Instance"} {
        $vclass addCategory $newname
    } elseif {$viewtype eq "Class"} {
        $vclass addCategoryB $newname
    }
    my refreshView
}
IDE::MethodCategoryView instproc refreshView {} {
    my instvar vclass win vobjtype viewtype

    [self]::stateButton setStateAddInfo Class [format %2i [llength [$vclass info procs]]]
    if {$vobjtype eq "Classes"} {
        [self]::stateButton setStateAddInfo Instance [format %2i [llength [$vclass info instprocs]]]
    }
    set allcatName _all_categories
    if {$viewtype eq "Instance"} {
        set categories [IDE::IntroProxy getCategoriesForClass $vclass]
        set catWithCount [list]
        foreach c $categories {
            set item [list $c ([llength [IDE::IntroProxy getInstanceMethods $vclass [list $c]]])]
            if {$c eq "_all_categories"} {
                set allcatName $item
            }
            lappend catWithCount $item
        }
        my setList $catWithCount
    } elseif {$viewtype eq "Class"} {
        set categories [IDE::IntroProxy getCategoriesForObject $vclass]
        set catWithCount [list]
        foreach c $categories {
            set item [list $c ([llength [IDE::IntroProxy getClassMethods $vclass [list $c]]])]
            if {$c eq "_all_categories"} {
                set allcatName $item
            }
            lappend catWithCount $item
        }
        my setList $catWithCount
    }
    return $allcatName
}
IDE::MethodCategoryView instproc renameCategory actual {
    my instvar viewtype vclass
    set newname [::IDE::IDialogEntry getValue {type the new name} $actual]
    if {$newname eq "" || $newname==$actual} return
    if {$viewtype eq "Instance"} {
        $vclass renameCategory $actual $newname
    } elseif {$viewtype eq "Class"} {
        $vclass renameCategoryB $actual $newname
    }
    my renameItem $actual $newname
}
IDE::MethodCategoryView instproc selectFor {class objtype} {
    my instvar vclass win vobjtype viewtype selectAllByDefault
    set vclass $class
    if {$class eq ""} {
        my resetList
        [my info parent]::methodview selectFor {} {} $viewtype
        return
    }
    if {$objtype eq "Procs"} {
        my resetList
        [my info parent]::methodview selectFor $class {} $objtype
        set vobjtype $objtype
        [self]::stateButton setStates {}
        return
    }
    if {$vobjtype!=$objtype} {
        if {$objtype eq "Objects"} {
            [self]::stateButton setStates {Class}
            [self]::stateButton setStateAddInfo Instance "  "
        } elseif {$objtype eq "Classes"} {
            [self]::stateButton setStates {Instance Class}
        }
        set viewtype [[self]::stateButton state]
        set vobjtype $objtype
    }
    set allcatName [my refreshView]
    if {$selectAllByDefault} {
        my setSelectedItem $allcatName
    } else {
        my selectItem {}
    }
}
IDE::MethodCategoryView instproc selectItem cat {
    my instvar vclass viewtype
    if {[Object isobject [my info parent]::methodview]} {
        # remove trailing count of items if exists
        regexp {(.+) \([0-9]+\)} $cat _ cat
        [my info parent]::methodview selectFor $vclass [list $cat] $viewtype
    }
}
Class IDE::MethodEditSynchronizatorMix
@ ::IDE::MethodEditSynchronizatorMix idemeta component IDEView
IDE::MethodEditSynchronizatorMix instproc getKeyFromBody script {
   set nclass [lindex $script 0]
   set ntype [lindex $script 1]
   set nmethod [lindex $script 2]

   if {$nclass eq "proc"} {
       set pobj [IDE::TclProcsDescription getMethodFor $ntype]
       return [list $pobj Procs $ntype]
   } else {
       if {$ntype eq "instproc"} {
           set ntype Instance
       } else {
           set ntype Class
       }
       return [list $nclass $ntype $nmethod]
   }
}
IDE::MethodEditSynchronizatorMix instproc registerKeyForInstance key {
    IDE::MethodEditSynchronizatorMix instvar synchArr synchEditors
    set instance [self]
    if {[info exists synchEditors($instance)]} {
        set okey $synchEditors($instance)
        if {$okey ne $key} {
            set current $synchArr($okey)
            ide::lremove current $instance
            if {[llength $current]==0} {
                unset synchArr($okey)
            } else {
                set synchArr($okey) $current
            }
        }
    }
    set synchEditors($instance) $key

    if {[info exists synchArr($key)]} {
        set current $synchArr($key)
        lappend current $instance
        set synchArr($key) [lsort -unique $current]
    } else {
        set synchArr($key) $instance
    }
}
IDE::MethodEditSynchronizatorMix instproc saveValue value {
    next
    my instvar vclass vctype method editMode
    # problems
    # 1 new methods
    # 2 methods with inside changed bodies
    if {![info exists vclass]} {
        return
    }
    set instance [self]
    set key "$vclass $vctype $method"
    set nkey [my getKeyFromBody $value]
    if {[lindex $nkey 0] eq ""} return
    if {$key ne $nkey} {
        my registerKeyForInstance $nkey
        set key $nkey
    }
    IDE::MethodEditSynchronizatorMix instvar synchArr synchEditors
    if {$editMode eq "xotcl" && [info exists synchArr($key)]} {
        set viewList $synchArr($key)
        set twin [my getTextWindow]
        foreach view $viewList {
            if {$view ne $instance && [Object isobject $view]} {
                if {[$view hasModifications]} {
                    IDE::Dialog message "There are also modified unsaved $method in another view. No view synchronisation. Please beware your changes"
                    continue
                }
                if {![info exists dump]} {
                    set dump [$twin dump -text -tag 1.0 end]        
                }
                set targetWin [$view getTextWindow]
                $targetWin configure -undo 0
                $targetWin delete 1.0 end
                set currTags [list]
                foreach {key value index} $dump {
                    switch $key {
                        text {
                            $targetWin insert $index $value $currTags
                        }
                        tagon {
                            lappend currTags $value
                        }
                        tagoff {
                            ide::lremove currTags $value
                        }
                    }
                }
                $targetWin configure -undo 1
                $targetWin edit modified 0
            }
        }
    }
}
IDE::MethodEditSynchronizatorMix instproc setBodyTextControler {tvclass tvtype tmethod controler} {
    next
    set key "$tvclass $tvtype $tmethod"
    my registerKeyForInstance $key
}
Class IDE::MethodListView -superclass {::IDE::ListView ::IDE::GUICommands}
@ ::IDE::MethodListView idemeta component IDEView
IDE::MethodListView instproc askForItemChange {} {
    [my info parent]::methodedit askForModification
}
IDE::MethodListView instproc browseChildren actual {
     set item [split $actual >]
     set vclass [lindex [lindex $item 0] 0]
     if {[Object isclass $vclass]} {
         IDE::HeritageBrowser newBrowserChild $vclass
     } else {
         my upsMessage "$vclass is not a class"
     }
}
IDE::MethodListView instproc browseHeritage actual {
    set item [split $actual >]
    set vclass [lindex [lindex $item 0] 0]
    if {[Object isclass $vclass]} {
        IDE::HeritageBrowser newBrowser $vclass
    } else {
        my upsMessage "$vclass is not a class"
    }
}
IDE::MethodListView instproc editSave skript {
    namespace  eval :: $skript
}
IDE::MethodListView instproc fillMenuStruct ms {
    $ms enablementHandler [self]
    $ms addCommand2 {Remove form List} [list [self] dispatchWithSelected removeMethod] isValidSelection
    $ms addCommand2 {Heritage Browser} [list [self] dispatchWithSelected browseHeritage] isValidSelection
    $ms addCommand2 {Children Browser} [list [self] dispatchWithSelected browseChildren] isValidSelection
    $ms addCommand2 {Search Senders} [list [self] dispatchWithSelected searchSenders] isValidSelection
    $ms addCommand2 {Search Implementors} [list [self] dispatchWithSelected searchImplementors] isValidSelection
    $ms addSeparator
    $ms addCommand {View next item} [list [self] selectNextItem] {} Alt-n
    $ms addCommand {View previous item} [list [self] selectPrevItem] {} Alt-p
    my menuInsertions $ms
    next
}
IDE::MethodListView instproc getMenuStruct {} {
    IDE::MenuStruct create [self]::ms Methods 0
}
IDE::MethodListView instproc removeMethod actual {
    my removeItem $actual
}
IDE::MethodListView instproc searchImplementors actual {
    set method [lindex [split $actual >] 1]
    IDE::MethodBrowser searchImplementorsAll $method
}
IDE::MethodListView instproc searchSenders actual {
    set method [lindex [split $actual >] 1]
    IDE::MethodBrowser searchSendersAll $method
}
IDE::MethodListView instproc selectClassTypeMethod {class type method} {
    [my info parent]::methodedit setBodyText $class $type $method
}
IDE::MethodListView instproc selectItem item {
    if {$item eq ""} return
    if {[lindex $item 0] eq "proc"} {
        set method [lindex $item 1]
        set type "Procs"
        set class [IDE::TclProcsDescription getMethodFor [string trimleft $method :]]
        if {$class ne ""} {
            set class [$class getGroupObj]
        }
    } else {
        set item [split $item >]
        set method [lindex $item 1]
        set type [lindex [lindex $item 0] 1]
        if {$type eq ""} { set type Instance} else { set type Class}
        set class [string trimleft [lindex [lindex $item 0] 0] :]
    }
    my selectClassTypeMethod $class $type $method
    [my info parent] colorizeSearchString
}
Class IDE::MethodSelector
@ ::IDE::MethodSelector idemeta component IDEView
IDE::MethodSelector proc getMethod {} {
    IDE::IDialogEntry [self]::classentry -message {Give method name or glob patern} -entry *
    if {[[self]::classentry prompt] ne "ok"} {
        [self]::classentry destroy
         return {}
    }
    set result [[self]::classentry entry]
    [self]::classentry destroy
    if {![regexp -- {\*} $result]} {
        return $result
    }
    set mlist [my getMethodsForPattern $result]
    if {[llength $mlist]==0} {
        return {}
    }
    IDE::IDialogList [self]::classlist -message {Choose the class} -list [lsort -unique $mlist]
    if {[[self]::classlist prompt] ne "ok"} {
        [self]::classlist destroy
        return {}
    }
    set result [[self]::classlist selectedItem]
    [self]::classlist destroy
    return $result
    
}
IDE::MethodSelector proc getMethodsForPattern patern {
    set mlist {}
    foreach class [::IDE::IntroProxy getClasses]  {
        set mlist [concat $mlist [$class info instprocs $patern] [$class info procs $patern]]
    }
    foreach class [IDE::IntroProxy getObjects] {
        set mlist [concat $mlist [$class info procs $patern]]
    }
     
    return $mlist
}
Class IDE::MethodView -superclass {::IDE::ListView ::IDE::GUICommands ::IDE::FocusPerKey} -parameter {{label Methods}}
@ ::IDE::MethodView idemeta categories {interface handle-editing private user_actions initialize selectionstate special_actions search}
@ ::IDE::MethodView idemeta categoriesMethods {{handleScript editSave selectItem selectFor} {editSaveComment refreshActual syntaxCheck selectHItem selectHItemRefresh refreshView checkItem getEditText} getComponentInContext {convertProcToMethod backMethod closeAllSpawned forwardMethod newInitializeAfterLoad newOverwriteMethodTemplate deleteMethod invokeProcs newMethodTemplate moveToCategory} {fillMenuStruct init getMenuStruct} {isValidContext isSelectionProc isSelectionTclProc} {insertMethodToEdit selectionToMethod spawnMethod spawnMethodUnderCursor viewMethodUnderCursor} {searchImplementors searchSenders searchText}}
@ ::IDE::MethodView idemeta component IDEView
IDE::MethodView instproc askForItemChange {} {
    [my info parent]::methodedit askForModification
}
IDE::MethodView instproc backMethod {} {
    my instvar history historyIndex
    while {$historyIndex>=1} {
        incr historyIndex -1
        set hitem [lindex $history $historyIndex]
        if {[my checkItem $hitem]} {
            my selectHItemRefresh $hitem
            break
        }
        set history [lreplace $history $historyIndex $historyIndex]
    }
}
IDE::MethodView instproc changeInheritedMethodView {} {
    my instvar vclass vtype vcategories
    my selectFor $vclass $vcategories $vtype
}
IDE::MethodView instproc checkItem hitem {
    foreach {vclass vtype method} $hitem {}
    if {![Object isobject $vclass]} {return 1}
    switch $vtype {
        Class {
            if {[$vclass info procs $method] eq ""} {return 0}
        }
        Instance  {
            if {[$vclass info instprocs $method] eq ""} {return 0}
        }
        Procs {
            if {[info procs ::$method] eq ""} {return 0}
        }
    }
    return 1
}
IDE::MethodView instproc closeAllSpawned {} {
    foreach obj [my info children] {
        if {[$obj istype IDE::SpawnMethodEdit]} {
            $obj destroy
        }
    }
}
IDE::MethodView instproc convertProcToMethod procs {
    IDE::ProcToMethodWizzard convertProcedures $procs
}
IDE::MethodView instproc deleteMethod method {
    my instvar vtype vclass
    if {$vtype eq "Instance"} {
        $vclass instproc $method {} {}
        $vclass uncategoryFor $method
    } elseif {$vtype eq "Class"} {
        $vclass proc $method {} {}
        $vclass uncategoryForB $method
    } elseif {$vtype eq "Procs"} {
        $vclass deleteMethod $method
    }
    my selectItem {}
    my removeItem $method
}
IDE::MethodView instproc editSave skript {
   my instvar vtype vclass actItem history historyIndex vcategories
   if {![info complete $skript]} {
       IDE::Dialog message {This is not complete Tcl-Script. Check the paratness}
       return
   }
   if {$vtype eq "Procs" && [lindex $skript 0] eq "proc"} {
       set procname [$vclass handleScript $skript]
   } else {
       namespace  eval :: $skript
   }
   set nclass [lindex $skript 0]
   set ntype [lindex $skript 1]
   set nmethod [lindex $skript 2]
   if {[info exists actItem] && $actItem ne ""} {
       foreach {oclass otype omethod} $actItem {}
   } else {
       set oclass $vclass
       set omethod {}
       set otype $vtype
   }
   if {$nclass eq "proc"} {
       if {$nmethod eq $omethod} {
           return
       } else {
           if {$otype eq "Procs" && $procname ne ""} {
               set hitem [list $oclass $otype $procname]
               my addItem $procname
               my setSelectedItem $procname 0
           } else {
               return
           }
       }
   } else {
       if {$ntype eq "instproc"} {
           set ntype Instance
       } else {
           set ntype Class
       }
       if {$nmethod eq $omethod && $ntype eq $otype && $nclass eq $oclass} {
           return
       } else {
           set hitem [list $nclass $ntype $nmethod]
           if {$ntype eq $vtype && $nclass eq $vclass && ($vcategories eq "_all_categories" || $vcategories eq "_uncategorized")} {
               my addItem $nmethod
               my setSelectedItem $nmethod 0
           }
       }
   }
    incr historyIndex
    set history [linsert $history $historyIndex $hitem]
}
IDE::MethodView instproc editSaveComment comment {
   my instvar actItem
   set vclass [lindex $actItem 0]
   set vtype [lindex $actItem 1]
   set method [lindex $actItem 2]
   $vclass setMethodComment $vtype $method $comment
   
}
IDE::MethodView instproc fillMenuStruct ms {
    $ms enablementHandler [self]
    $ms enableList isValidContext

    [$ms addCommand {Back Method} [list [self] backMethod] {} {Alt-Left}] enableList noglobal
    [$ms addCommand {Forward Method} [list [self] forwardMethod] {} {Alt-Right}] enableList noglobal
    $ms addCommand {View Method under Cursor} [list [self] viewMethodUnderCursor] {} {Control-m}
    $ms addCommand {Spawn View} [list [self] spawnMethod]
    $ms addCommand {Spawn Method under Cursor} [list [self] spawnMethodUnderCursor] {} {Control-n}
    $ms addCommand {Selection to new method} [list [self] selectionToMethod]
    $ms addCommand {Close All Spawned} [list [self] closeAllSpawned]
    $ms addCheckButton {Show Inherited Methods} [self]::inheritedMethod [list [self] changeInheritedMethodView]
    $ms addSeparator
    $ms addCommand2 Delete [list [self] dispatchWithSelectedMulti deleteMethod] isValidSelection
    $ms addSeparator
    $ms addMenuItem [IDE::MenuCommand new -childof [self] -name {New Method Template} -command [list [self] newMethodTemplate] -popdownMenu 1 -accelerator {Control-k}]
    $ms addCommand2 {New Overwrite Method Template} [list [self] newOverwriteMethodTemplate]
    $ms addCommand2 {New initializeAfterLoad} [list [self] newInitializeAfterLoad]
    $ms addCommand3 {Convert To XOTcl-Method} [list [self] dispatchWithSelectedAll convertProcToMethod] isSelectionTclProc
    $ms addSeparator

    IDE::MenuStruct ${ms}::searchText {Search Text} -popdownMenu 1
    $ms addCascadeMenu ${ms}::searchText
    ${ms}::searchText addCommand2 {Local} [list [self] searchText local] noglobal
    ${ms}::searchText addCommand2 {In Component} [list [self] searchText component] noglobal
    ${ms}::searchText addMenuItem [IDE::MenuCommand new -childof ${ms}::searchText -name All -command [list [self] searchText all] -popdownMenu 1 -enableList noglobal -accelerator F4]

    IDE::MenuStruct ${ms}::searchImplementors {Search Implementors} -popdownMenu 1
    $ms addCascadeMenu ${ms}::searchImplementors
    ${ms}::searchImplementors addCommand2 {Local} [list [self] searchImplementors local] isValidSelection
    ${ms}::searchImplementors addCommand2 {In Component} [list [self] searchImplementors component] isValidSelection
    ${ms}::searchImplementors addCommand2 {All} [list [self] searchImplementors all] isValidSelection
    IDE::MenuStruct ${ms}::searchSenders {Search Senders} -popdownMenu 1
    $ms addCascadeMenu ${ms}::searchSenders
    ${ms}::searchSenders addCommand2 {Local} [list [self] searchSenders local] isValidSelection
    ${ms}::searchSenders addCommand2 {In Component} [list [self] searchSenders component] isValidSelection
    ${ms}::searchSenders addCommand2 {All} [list [self] searchSenders all] isValidSelection

    my menuInsertions $ms
    $ms addSeparator
    $ms addCommand2 {Invoke Procs} [list [self] dispatchWithSelected invokeProcs] [list isValidSelection isSelectionProc]
    $ms addCommand2 {Change Category} [list [self] dispatchWithSelectedAll moveToCategory] isValidSelection
    next
}
IDE::MethodView instproc forwardMethod {} {
    my instvar history historyIndex
    while {$historyIndex<[expr {[llength $history]-1}]} {
        incr historyIndex 1
        set hitem [lindex $history $historyIndex]
        if {[my checkItem $hitem]} {
            my selectHItemRefresh $hitem
            break
        }
        set history [lreplace $history $historyIndex $historyIndex]
    }
}
IDE::MethodView instproc getComponentInContext {} {
    if {[Object isobject [my info parent]::appview]} {
        return [[my info parent]::appview selectedItem]
    } else {
        return [[my set vclass] getComponentName]
    }
}
IDE::MethodView instproc getEditText hitem {
    set vclass [lindex $hitem 0]
    set vtype [lindex $hitem 1]
    set method [lindex $hitem 2]
    set ret {}
    if {$vtype eq "Procs"} {
        if {[Object isobject $vclass]} {
            set pobj [$vclass getProcObjForNameIfExist $method]
            if {$pobj ne ""} {
                set ret [$pobj getBody]
            }
        }
    } else {
        set ret [IDE::IntroProxy getBody${vtype}MethodIfExist $vclass $method]
    }
    if {$ret eq ""} {
        return "# Method $method in $vclass was probably deleted from the System"
    }
    return $ret
}
IDE::MethodView instproc getMenuStruct {} {
    IDE::MenuStruct create [self]::ms Method 0
}
IDE::MethodView instproc handleScript script {
    # only used by child classes
}
IDE::MethodView instproc init args {
    my instvar vclass win history historyIndex vtype inheritedMethod
    # saveEdit need vtype
    set vtype Instance
    set history {}
    set historyIndex -1
    set vclass {}
    set inheritedMethod 0
    next
    bind $win.listbox <2> [list [self] insertMethodToEdit %y]
    bind $win.listbox <Insert> [list [self] newMethodTemplate]
}
IDE::MethodView instproc insertMethodToEdit y {
    my instvar win listItems
    [my info parent]::methodedit appendToCursor "[lindex $listItems [$win.listbox nearest $y]] "
}
IDE::MethodView instproc invokeProcs actual {
    my instvar vclass vtype
    if {$vtype eq "Class"} {
        IDE::System invokeProc $vclass $actual
    } elseif {$vtype eq "Procs"} {
        IDE::System invokeTclProc $actual
    }
}
IDE::MethodView instproc isSelectionProc {} {
    expr {[my set vtype] eq "Class" || [my set vtype] eq "Procs"}
}
IDE::MethodView instproc isSelectionTclProc {} {
    expr {[string equal [my set vtype] "Procs"]}
}
IDE::MethodView instproc isValidContext {} {
    expr {[my exists vclass] && [my set vclass] ne ""}
}
IDE::MethodView instproc moveToCategory methods {
    my instvar vclass vcategories vtype
    set tcategories [[my info parent]::methodcatview set listItems]
    set categories [list]
    foreach c $tcategories {
        regexp {(.+) \([0-9]+\)} $c _ c
        lappend categories $c
    }
    IDE::IDialogListEntry [self]::dialog -message {Choose the category or name the new one} -list $categories
    if {[[self]::dialog prompt] eq "ok"} {
        set cat [[self]::dialog getvalue]
        if {$cat ne ""} {
            if {$vcategories!=$cat} {
                foreach method $methods {
                    if {$vtype eq "Instance"} {
                         $vclass moveToCategory $method $cat
                    } else {
                         $vclass moveToCategoryB $method $cat
                    }
                    if {$vcategories ne "_all_categories"} {
                        my removeItem $method
                    }
                }
                [my info parent]::methodcatview refreshView
            }
        }
    }
    [self]::dialog destroy
}
IDE::MethodView instproc newInitializeAfterLoad {} {
    my instvar vclass
    [my info parent]::methodedit setTextControler "$vclass proc initializeAfterLoad {} {\n    # init your class varibales and other stuff\n}" [self]
    [my info parent]::methodedit setSelection "2.4" "2.4 lineend"
    my prepareNewMethodState
}
IDE::MethodView instproc newMethodTemplate {} {
    my instvar vclass vtype
    if {[Object isclass $vclass] && $vtype eq "Instance"} {
        set proc instproc
    } else {
        set proc proc
    }
    set procName [[my info parent]::methodedit getSelection]
    if {![regexp -- {\w+} $procName]} {
        set procName procName
    }
    if {$vtype eq "Procs"} {
        if {[$vclass withNamespace]} {
            set pre [$vclass getObjectName]::
        } else {
            set pre {}
        }
        set text "proc ${pre}$procName {args} {\n    # enter the body hier\n}\n"
        set start [string length "proc ${pre}"]
    } else {
        set text "$vclass $proc $procName {args} {\n    # enter the body hier\n}\n"
        set start [string length "$vclass $proc "]
    }
    [my info parent]::methodedit setTextControler $text [self]
    if { $procName eq "procName" } {
        set stop [expr {$start + [string length $procName]}]
        [my info parent]::methodedit setSelection "1.0 + $start chars" "1.0 + $stop chars"
    } else {
        [my info parent]::methodedit setSelection "2.4" "2.4 lineend"
    }
    my prepareNewMethodState
}
IDE::MethodView instproc newOverwriteMethodTemplate {} {
    my instvar vclass
    if {![Object isclass $vclass]} {
        my upsMessage "$vclass is not a class"
        return
    }
    set methods [list]
    foreach c [$vclass info heritage] {
        if {$c eq "::xotcl::Object"} continue
        set methods [concat $methods [$c getAllInstMethods ::xotcl::Object]]
    }
    set methods [lsort -unique $methods]
    ide::lremoveAll methods [$vclass info instprocs]
    if {$methods eq ""} {
        IDE::Dialog message "Nothing to overwrite"
        return
    }
    set procName [IDE::IDialogList getListItem {Select method to overwrite} $methods]
    set args {}
    foreach c [$vclass info heritage] {
        if {[ide::lcontain [$c info instprocs] $procName]} {
            set args [list [$c info instargs $procName]]
            break
        }
    }
    if {$procName eq ""} return
    [my info parent]::methodedit setTextControler "$vclass instproc $procName $args {\n    # enter the body hier\n}\n" [self]
    [my info parent]::methodedit setSelection "2.4" "2.4 lineend"
    my prepareNewMethodState
}
IDE::MethodView instproc prepareNewMethodState {} {
    my unselect
    [my info parent]::methodedit focus
    # We want to change state to Source but do not provoke events
    # quite dirty
    [my info parent]::methodedit set vtype Source
    set sb [my info parent]::stateButton
    if {[Object isobject $sb]} {
        $sb setActivity 0
        $sb changeStateTo Source 0
    }
}
IDE::MethodView instproc refreshActual {} {
    my instvar history historyIndex
    my selectHItem [lindex $history $historyIndex]
}
IDE::MethodView instproc refreshView {} {
    my instvar actItem
    if {$actItem eq ""} return
    set editVType [[my info parent]::stateButton state]
    set vtclass [lindex $actItem 0]
    set vtype [lindex $actItem 1]
    set method [lindex $actItem 2]
    if {$editVType eq "Comment"} {
        set comment [$vtclass getMethodComment $vtype $method]
        [my info parent]::methodedit setTextControler $comment [self]
        [my info parent]::stateButton setActivity 0
    } elseif {$editVType eq "Source"} {
        my selectHItem $actItem
        set sb [my info parent]::stateButton
        if {[Object isobject $sb]} {
            set hasComment [$vtclass hasMethodComment $vtype $method]
            $sb  setActivity $hasComment
        }
    } elseif {$editVType eq "Splited"} {
        my selectHItem $actItem
        set comment [$vtclass getMethodComment $vtype $method]
        [my info parent] @comment setTextTypeControler $comment Comment [self]
        [my info parent]::stateButton setActivity 0

    } else {
        error {Unknown view type}
    }
}
IDE::MethodView instproc searchImplementors range {
    my instvar vclass
    set implementor [my selectedItemFirst]
    if {$implementor ne ""} {
        switch -- $range {
            local {IDE::MethodBrowser searchImplementorsClass $implementor $vclass}
            component {
                IDE::MethodBrowser searchImplementorsComponent $implementor [my getComponentInContext]
            }
            all {IDE::MethodBrowser searchImplementorsAll $implementor}
        }
    }
}
IDE::MethodView instproc searchSenders range {
    my instvar vclass
    set text [my selectedItemFirst]
    if {$text ne ""} {
        set pattern \[\[:<:\]\]${text}\[\[:>:\]\]
        switch -- $range {
            local {IDE::MethodBrowser searchTextClass $pattern $vclass $text}
            component {
                IDE::MethodBrowser searchTextComponent $pattern [my getComponentInContext] $text
            }
            all {IDE::MethodBrowser searchTextAll $pattern $text}
        }
    }
}
IDE::MethodView instproc searchText range {
    my instvar vclass
    set sel [[my info parent]::methodedit getSelection]
    set text [IDE::IDialogEntry getValue {give search text (regular expresion)} $sel]
    if {$text ne ""} {
        switch $range {
            local {IDE::MethodBrowser searchTextClass $text $vclass}
            component {
                IDE::MethodBrowser searchTextComponent $text [my getComponentInContext]
            }
            all {IDE::MethodBrowser searchTextAll $text}
        }
    }
}
IDE::MethodView instproc selectFor {class categories type} {
    my instvar vclass vtype vcategories inheritedMethod
    if {$class eq ""} {
        my resetList
        set vclass {}
    } elseif {$type eq "Procs"} {
        set cobj [[my info parent] getActualComponentObject]
        set vclass [$cobj getProcsGroupWithName $class]
        if {$vclass eq ""} return
        my setList [$vclass getProcsNames]
    } else {
        if {$categories eq ""} {
            set vclass {}
            my resetList
        } else {
            if {$inheritedMethod && $type eq "Instance"} {
                set inheritedMethods [list]
                set ownMethods [IDE::IntroProxy getInstanceMethods $class $categories]
                foreach c [lrange [$class info heritage] 0 end-1] {
                    foreach m [IDE::IntroProxy getInstanceMethods $c $categories] {
                        if {[lsearch $ownMethods $m]!=-1 || [lsearch $inheritedMethods $m]!=-1} continue
                        lappend inheritedMethods $m
                    }
                }
                set allMethods [lsort [concat $ownMethods $inheritedMethods]]
                my setListUnsorted $allMethods
                foreach m $inheritedMethods {
                    my markItemIndexForeGround [lsearch $allMethods $m] darkgreen
                }
            } else {
                my setList [IDE::IntroProxy get${type}Methods $class $categories]
            }
            set vclass $class
        }
    }
    # mark blue fresh methods (new in this session)
    set vtype $type
    if {$vclass ne ""} {
        set des [$vclass getDescription]
        if {$des ne ""} {
            set x 0
            foreach method [my getList] {
                if {[$des istype IDE::ProcsGroup]} {
                    set mobj [$des getProcObjForNameIfExist $method]
                    if {$mobj ne "" && [$mobj isPersistent] && [$mobj istFreshInserted]} {
                        my markItemIndexForeGround $x blue
                    }
                } else {
                    if {$vtype eq "Class"} {
                        set mobj [${vclass}::description getClassMethodObjName $method]
                    } else {
                        set mobj [${vclass}::description getInstanceMethodObjName $method]
                    }
                    if {[Object isobject $mobj] && [$mobj istFreshInserted]} {
                        my markItemIndexForeGround $x blue
                    }
                }
                incr x
            }
        }
    }
    set vcategories $categories
    my selectItem {}
}
IDE::MethodView instproc selectHItem hitem {
    [my info parent]::methodedit setBodyTextControler [lindex $hitem 0] [lindex $hitem 1] [lindex $hitem 2] [self]
}
IDE::MethodView instproc selectHItemRefresh hitem {
    set parent [my info parent]
    if {$parent ne "" && [$parent info methods refreshHItem] ne ""} {
        $parent refreshHItem $hitem
    }
    my set actItem $hitem
    my refreshView
    my setSelectedItem [lindex $hitem end] 0
}
IDE::MethodView instproc selectItem method {
    my instvar vclass vtype history historyIndex actItem inheritedMethod
    set actItem {}
    if {$method eq ""} {
        # [my info parent]::methodedit setTextControler {} [self]
        return
    }
    if {$inheritedMethod && $vtype eq "Instance"} {
        foreach c [concat $vclass [$vclass info heritage]] {
            if {[$c info instprocs $method] ne ""} {
                set actItem [list $c $vtype $method]
                break
            }
        }
    } else {
        set actItem [list $vclass $vtype $method]
    }
    if {[lindex $history $historyIndex]!=$actItem} {
        incr historyIndex
        set history [linsert $history $historyIndex $actItem]
    }
    my refreshView
}
IDE::MethodView instproc selectionToMethod {} {
    my instvar vclass vtype
    set selection [[my info parent]::methodedit getSelection]
    if {$selection ne ""} {
        if {$vtype eq "Instance"} {
            set pname instproc
        } else {
            set pname proc
        }
        set text "$vclass $pname yourProcName {} {\n$selection\n}"
        set obj [IDE::SpawnMethodEdit new -childof [self] [Object autoname .spawnedmethod]]
        ${obj}::methodedit setTextControler $text [self]
        my prepareNewMethodState
    }
}
IDE::MethodView instproc spawnMethod {} {
    set text [[my info parent]::methodedit getText]
    if {$text ne ""} {
        set obj [IDE::SpawnMethodEdit new -childof [self] [Object autoname .spawnedmethod]]
        ${obj}::methodedit setTextControler $text [self]
        ${obj}::methodedit ignoreNoChanges
        # The script can be not proper tcl list
        catch {$obj setTitleAddition "[lindex $text 0]>>[lindex $text 2]"}
    }
}
IDE::MethodView instproc spawnMethodUnderCursor {} {
    my instvar vclass vtype
    set word [[my info parent]::methodedit getWordUnderCursor]
    set sclass $vclass
    set stype $vtype
    set smethod {}
    #[self] halt
    if {[regexp -- {[a-zA-Z]\w+} $word]} {
        if {$stype eq "Instance"} {
            if {[$sclass info instprocs $word] ne ""} {
                set smethod $word
            } else {
                foreach pair [$vclass getAllFullInstMethods] {
                    if {[lindex $pair 1]==$word} {
                        set sclass [lindex $pair 0]
                        set smethod $word
                    }
                }
            }
        } elseif {$stype eq "Class"} {
            if {[$sclass info procs $word] ne ""} {
                set smethod $word
            }
        }
    }
    if {$smethod ne ""} {
        set obj [IDE::SpawnMethodEdit new -childof [self] [Object autoname .spawnedmethod]]
        ${obj}::methodedit setTextControler [my getEditText [list $sclass $stype $smethod]] [self]
    }
}
IDE::MethodView instproc syntaxCheck {text editor} {
    set context [PrsContext new -volatile]
    $context parseAndCheck $text
    if {[$context hasErrors]} {
        IDE::SyntaxErrorView new -errors [$context errors] -editor $editor -init [Object autoname .syntaxview]
        return 0
    } else {
        return 1
    }
}
IDE::MethodView instproc viewMethodUnderCursor {} {
    my instvar vclass vtype
    set word [[my info parent]::methodedit getWordUnderCursor]
    #[self] halt
    if {[regexp -- {[a-zA-Z]\w+} $word]} {
        if {$vtype eq "Instance"} {
            if {[$vclass info instprocs $word] ne ""} {
                my selectItem $word
            } else {
                foreach pair [$vclass getAllFullInstMethods] {
                    if {[lindex $pair 1]==$word} {
                        set vclass [lindex $pair 0]
                        my selectItem $word
                    }
                }
            }
        } elseif {$vtype eq "Class"} {
            if {[$vclass info procs $word] ne ""} {
                my selectItem $word
            }
        }
    }
}
Class IDE::ObjectBrowser -superclass {::IDE::Browser ::IDE::GUICommands} -parameter {{type single} {atHead 1}}
@ ::IDE::ObjectBrowser idemeta categories {private initialize actions}
@ ::IDE::ObjectBrowser idemeta categoriesMethods {{save setViewObject setViewList} {getMenuStruct specificInit fillMenuStruct} {inspectParent destroyActual browseClass browseMixins printFilters printSelf printString trackObject}}
@ ::IDE::ObjectBrowser idemeta component IDEView
IDE::ObjectBrowser instproc browseClass args {
    my instvar vobject
    if {[$vobject info class] ne "::xotcl::Object"} {
        IDE::HeritageBrowser newBrowser [$vobject info class]
    }
}
IDE::ObjectBrowser instproc browseMixins {} {
    my instvar vobject

    set listchooser [IDE::IDialogListOrderChooser new -volatile -message "Mixin Classes for $vobject" -listout [$vobject info mixin] -listin [IDE::IntroProxy getClasses]]

    set ret [$listchooser prompt]
    if {$ret ne "cancel"} {
        $vobject mixin [$listchooser set listout]
    }
}
IDE::ObjectBrowser instproc closeWindow {} {
    my instvar type vobject
    if {[[self]::methodedit askForModification]} {
        if {$type eq "single" && [Object isobject $vobject]} {
            if {[$vobject hasclass IDE::DestroyMixForward]} {
                $vobject unregisterDestroyForwardObj [self]
            }
        }
        next
    }
}
IDE::ObjectBrowser instproc destroyActual {} {
    my instvar vobject type
    if {[IDE::Dialog yesNo "Do you want to destroy $vobject?"] ne "yes"} {  
        return
    }
    $vobject destroy
    if {$type eq "list"} { 
        [self]::objectsview removeItem $vobject
        my setViewObject ""
    } else { 
        my destroy
    }
}
IDE::ObjectBrowser instproc fillMenuStruct ms {
   $ms enablementHandler [self]
   $ms addCommand2 Destroy [list [self] destroyActual] hasObject
   $ms addCommand2 {Track Object} [list [self] trackObject] hasObject
   $ms addCommand2 {Browse Class} [list [self] browseClass] hasObject
   $ms addCommand2 {Browse Mixins} [list [self] browseMixins] hasObject
   $ms addCommand2 {Print Self} [list [self] printSelf] hasObject
   $ms addCommand2 {Print printString} [list [self] printString] hasObject
   $ms addCommand2 {Print Filters} [list [self] printFilters] hasObject
}
IDE::ObjectBrowser instproc getMenuStruct {} {
   IDE::MenuStruct create [self]::ms Object 0
}
IDE::ObjectBrowser instproc getTitle {} {
    return "Object Inspector"
}
IDE::ObjectBrowser instproc hasObject {} {
    expr {[my set vobject] ne ""}
}
IDE::ObjectBrowser instproc inspectParent {} {
    my instvar vobject
    if {[set parent [$vobject info parent]] ne "::" && [Object isobject $parent]} {
        my setViewObject $parent
    } else {
        IDE::Dialog message "$vobject has no parent"
    }
}
IDE::ObjectBrowser instproc instanceDestroying {} {
    my destroy
}
IDE::ObjectBrowser instproc printFilters {} {
    [self]::methodedit setTextControler [[my set vobject] info filter] [self]
}
IDE::ObjectBrowser instproc printSelf {} {
    [self]::methodedit setTextControler [my set vobject] [self]
}
IDE::ObjectBrowser instproc printString {} {
    [self]::methodedit setTextControler [[my set vobject] printString] [self]
}
IDE::ObjectBrowser instproc save {} {
}
IDE::ObjectBrowser instproc setVarValue {value controller} {
    [self]::methodedit setTextControler $value $controller
}
IDE::ObjectBrowser instproc setViewList list {
     [self]::objectsview setListUnsorted $list
     my setViewObject ""
}
@ IDE::ObjectBrowser instproc setViewObject {} {
description {Return true if lock is setted on}
}
IDE::ObjectBrowser instproc setViewObject object {
    my instvar vobject
    set vobject $object
    [self]::methodedit set context $object
    if {$object ne ""} {
        my setTitleAddition "$object ([$object info class])"
    } else {
        my setTitleAddition ""
    }
    set locked [[self]::varsview selectFor $object]
    [self]::subobjectsview selectFor $object
    [self]::methodview selectFor $object
    return $locked
}
IDE::ObjectBrowser instproc specificInit {} {
    my instvar win type
    
    my set vobject ""

    panedwindow $win.panedwindow -orient vertical
    panedwindow $win.upperarea -orient horizontal

    IDE::TclModeEdit create [self]::methodedit $win.methodedit -height 16 -width 65
    if {$type ne "single"} {
        IDE::ObjectsView [self]::objectsview $win.upperarea.objectsview
        IDE::VarsView create [self]::varsview $win.upperarea.varsview -hasLock 1
        set col 1
    } else {
        IDE::VarsView create [self]::varsview $win.upperarea.varsview
        set col 0
    }
    IDE::SubObjectsView create [self]::subobjectsview $win.upperarea.subobjectsview
    IDE::ObjectMethodView create [self]::methodview $win.upperarea.methodview

    if { $col } {
        $win.upperarea add $win.upperarea.objectsview -width 200
    }
    $win.upperarea add $win.upperarea.varsview $win.upperarea.subobjectsview $win.upperarea.methodview -width 200

    $win.panedwindow add $win.upperarea -sticky news -height  120
    $win.panedwindow add $win.methodedit -sticky news -height 300

    pack $win.panedwindow -expand yes -fill both

    if {$::xotcl::version>=1.3} {
        [self]::methodedit mixin add IDE::ContextEval
    } else {
        [self]::methodedit mixinappend IDE::ContextEval
    }
    [self]::methodedit set context Object

    my initStatusBar 2 [expr {3+$col}]
}
IDE::ObjectBrowser instproc trackObject {} {
    [my set vobject] trackOn
}
IDE::ObjectBrowser proc browseAllInstances class {
    if {![Object isobject $class] || ![$class istype Class]} {
        return
    }
    set objectList [lsort [$class info instances]]
    if {$objectList eq ""} {
        IDE::Dialog message "$class has no instances"
    } elseif {[llength $objectList]==1} {
        my newBrowser $objectList
    } else {
        my browseObjectsList $objectList
    }
}
IDE::ObjectBrowser proc browseAllObjectInstances {} {
    set instances {}
    foreach instance [Object info instances] {
        if {![Object isobject [$instance info parent]] || [Object isclass [$instance info parent]]} {
            lappend instances $instance
        }
    }
    my browseObjectsList [lsort $instances]
}
IDE::ObjectBrowser proc browseAllObjects {} {
    set instances {}
    set ignoreClasses(::Class) 1
    set ignoreClasses(::Object) 1
    foreach class [lsort [::Class info instances]] {
        if {[info exists ignoreClasses($class)]} continue
        foreach instance [$class info instances] {
            if {![Object isobject [$instance info parent]] || [Object isclass [$instance info parent]]} {
                lappend instances $instance
            }
        }
    }
    my browseObjectsList [lsort $instances]
}
IDE::ObjectBrowser proc browseObjectsList list {
    set newinst [my create [Object autoname browser] [Object autoname .browser] -type list]
    $newinst setViewList $list
    return $newinst
}
IDE::ObjectBrowser proc browseObjectsListCheck list {
    set olist {}
    foreach elem $list {
        if {[Object isobject $elem]} {
            lappend olist $elem
        }
    }
    if {$olist eq ""} {
        IDE::Dialog message {The list contains no Xotcl Objects}
    } else {
        my browseObjectsList $list
    }
}
IDE::ObjectBrowser proc newBrowser object {
    if {![Object isobject $object]} {
        return
    }
    set newinst [my new [Object autoname .objectbrowser]]
    $newinst setViewObject $object
    IDE::DestroyMixForward registerDestroyForwardObj $object $newinst
    return $newinst
}
Class IDE::ObjectMethodView -superclass ::IDE::MethodView
@ ::IDE::ObjectMethodView idemeta component IDEView
IDE::ObjectMethodView instproc changeVisibility {} {
    my instvar vobject
    my selectFor $vobject
}
IDE::ObjectMethodView instproc fillMenuStruct ms {
    my set visibility MinusRoot
    $ms enablementHandler [self]

    $ms addCommand2 Invoke [list [self] dispatchWithSelected invokeMethod] isValidSelection
    $ms addCommand2 {Search Senders} [list [self] dispatchWithSelected searchSenders] isValidSelection
    $ms addCommand2 {Search Implementors} [list [self] dispatchWithSelected searchImplementors] isValidSelection
    $ms addRadioButton {Visibility All} [self]::visibility [list [self] changeVisibility] All
    $ms addRadioButton {Visibility Class} [self]::visibility [list [self] changeVisibility] Class
    $ms addRadioButton {Visibility All%::xotcl::Object} [self]::visibility [list [self] changeVisibility] MinusRoot
    $ms addCheckButton {no mixin methods} [self]::hideMixinMethod [list [self] changeVisibility]
    $ms addCheckButton {only instcommands} [self]::hideProcsMethod [list [self] changeVisibility]
    $ms addCheckButton {only procs} [self]::hideNoCmds [list [self] changeVisibility]
    $ms addCommand2 Refresh [list [self] changeVisibility]
}
IDE::ObjectMethodView instproc getMethodsFor {class visibility} {
    switch $visibility {
        Instance {
            return [ide::lcollect a [IDE::IntroProxy getInstanceMethods $class _all_categories] {list $a $class}]
        }
        All {
            return [$class getAllFullInstMethods]
        }
        MinusRoot {
            return [$class getAllFullInstMethods ::xotcl::Object]
        }
    }
}
IDE::ObjectMethodView instproc invokeMethod actual {
    set obj [[my info parent] set vobject]
    set method [lindex $actual 0]
    set signature [$obj procsearch $method]
    if {$signature eq ""} {
        if {[llength $actual]==2} {
            set class [lindex $actual 1]
            set args [$class info instargs $method]
        } else {
            IDE::System invokeInstproc $obj $method
            return
        }
    } else {
        set class [lindex $signature 0]
        set type [lindex $signature 1]
        if {$type eq "proc"} {
            set args [$class info args $method]
        } else {
            set par [ide::lcollect each [$class info parameter] {lindex $each 0}]
            # method is a parameter
            if {[ide::lcontain $par $method]} {
                IDE::System invokeProcWithArg $obj $method value 1
            } else {
                IDE::System invokeInstproc $obj $method
            }
        }
    }
}
IDE::ObjectMethodView instproc searchImplementors actual {
    IDE::MethodBrowser searchImplementorsAll [lindex $actual 0]
}
IDE::ObjectMethodView instproc searchMixinClass {object method} {
    foreach c [$object info mixin] {
        foreach sc [concat $c [$c info heritage]] {
            if {[$sc info instprocs $method] ne ""} {return $sc}
        }
    }
}
IDE::ObjectMethodView instproc searchSenders actual {
    IDE::MethodBrowser searchSendersAll [lindex $actual 0]
}
IDE::ObjectMethodView instproc selectFor object {
    my instvar vclass visibility vobject hideMixinMethod hideProcsMethod hideNoCmds
    if {![my exists hideMixinMethod]} {
        my set hideMixinMethod 0
    }
    if {![my exists hideProcsMethod]} {
        my set hideProcsMethod 0
    }
    if {![my exists hideNoCmds]} {
        my set hideNoCmds 0
    }
    set vcategories _all_categories
    set vobject $object
    if {$object eq ""} {
        my setList {}
    } else {
        set options {}
        foreach {var option} {hideMixinMethod -nomixins hideProcsMethod -noprocs hideNoCmds -nocmds} {
            if {[set $var]} {
                append options " $option"
            }
        }
        set methods [lsort -unique [eval $object info methods $options]]
        set class [$object info class]
        set smethods {}
        foreach m $methods {
            set dobj [lindex [$object procsearch $m] 0]
            # !!! if parameter has default the method below do not work
            # also yet no filtering. Maybe the user what to set parameter in this way
            # if {[ide::lcontain [$class info parameter] $m]} continue
            if {[$object info children $m] ne ""} continue
            if {$dobj eq ""} {
                lappend smethods [list $m [my searchMixinClass $vobject $m]]
            } else {
                if {$visibility eq "Class"} {
                    if {$dobj==$class} {
                        lappend smethods $m
                    }
                } elseif {$visibility eq "MinusRoot"} {
                    if {$dobj ne "::xotcl::Object"} {
                        lappend smethods [list $m [string trimleft $dobj :]]
                    }
                } else {
                    lappend smethods [list $m [string trimleft $dobj :]]
                }
            }
        }
        my setList $smethods
        set vclass $class
    }
    my selectItem {}
}
IDE::ObjectMethodView instproc selectItem method {
    my instvar vclass vtype vobject
    if {$method eq "" || ![Object isobject $vobject]} return
    set def [$vobject procsearch [lindex $method 0]]
    if {$def eq ""} {
        set type Instance
        set class [lindex $method 1]
        set method [lindex $method 0]]
    } else {
        set class [lindex $def 0]
        set dtype [lindex $def 1]
        set method [lindex $def 2]
        if {$dtype eq "instproc"} {
            if {[$class info instprocs $method] ne ""} {
                set type Instance
            } else {
                set body "# no access to $def"
                [my info parent]::methodedit setTextControler $body [self]
                return
            }
        } else {
            set type Class
        }
    }
    [my info parent]::methodedit setBodyTextControler [string trimleft $class :] $type $method [self]
}
Class IDE::ObjectsView -superclass {::IDE::ListView ::IDE::GUICommands} -parameter {{type list}}
@ ::IDE::ObjectsView idemeta component IDEView
IDE::ObjectsView instproc askForItemChange {} {
    [my info parent]::methodedit askForModification
}
IDE::ObjectsView instproc selectItem object {
    my instvar type
    if {$type eq "list"} {
        if {[Object isobject $object]} {
            set locked [[my info parent] setViewObject $object]
            if {!$locked && [Object isobject [my info parent]::methodedit]} {
                [my info parent]::methodedit setTextControler [$object printString] [self]
            }
        } else {
            IDE::Dialog message "$object does not longer exist. It will be removed from the list"
            my removeItem $object
        }
    }
}
Class IDE::PackageLoader -superclass {::IDE::Browser ::IDE::GUICommands} -parameter {{atHead 1}}
@ ::IDE::PackageLoader idemeta categories init-release
@ ::IDE::PackageLoader idemeta categoriesMethods {{getTitle getMenuStruct createSystemMenu specificInit}}
@ ::IDE::PackageLoader idemeta component IDEView
IDE::PackageLoader instproc addPackageLocation {} {
    set dir [IDE::Dialog getDir]
    if {[lsearch ::auto_path $dir]>=0} {
        IDE::Dialog message "$dir already in auto_load path\n$::auto_path"
        return
    }
    if {$dir ne ""} {
        lappend ::auto_path $dir
        my initPackages
    }
}
IDE::PackageLoader instproc createSystemMenu {} {
    my createMenu
}
IDE::PackageLoader instproc fillMenuStruct aMenuStruct {
    $aMenuStruct enablementHandler [self]

    $aMenuStruct addCommand {Add Package Location} [list [self] addPackageLocation]
    $aMenuStruct addCommand {Refresh} [list [self] initPackages]
}
IDE::PackageLoader instproc getMenuStruct {} {
    IDE::MenuStruct create [self]::ms Packaging 0
}
IDE::PackageLoader instproc getTitle {} {
    return "Package Loader"
}
IDE::PackageLoader instproc initPackages {} {
    # init internal package list
    catch {package require dummy}
    set packages [list]
    foreach p [package names] {
        if {[catch [list package present $p]]} {
            lappend packages $p
        }
    }
    my @packages setList $packages
    my unselectState
}
IDE::PackageLoader instproc loadIntoWorkspace {} {
    set item [my @versions selectedItem]
    if {$item eq "" || [llength $item]<3 || [lindex $item 1] ne "Tcl"} return
    IDE::Transcript openFile [lindex $item 2]    
}
IDE::PackageLoader instproc loadPackage {} {
    my instvar selectedPackage
    set version [lindex [my @versions selectedItem] 0]
    IDE::Component loadPackage $selectedPackage $version
}
IDE::PackageLoader instproc loadPackageDirect {} {
    my instvar selectedPackage
    set version [lindex [my @versions selectedItem] 0]
    package require $selectedPackage $version
}
IDE::PackageLoader instproc searchRequirements {} {
    set item [my @versions selectedItem]
    if {$item eq "" || [llength $item]<3 || [lindex $item 1] ne "Tcl"} return
    set file [lindex $item 2]
    set f [open $file r]
    set rPackages [list]
    while {[gets $f line]>=0} {
        if {[regexp {package require\s+(\w+)} $line _ pack]} {
            lappend rPackages $pack
        }
    }
    close $f
    IDE::ResultBrowser newBrowser [join [lsort -unique $rPackages] \n]
}
IDE::PackageLoader instproc selectPackage package {
    my set selectedPackage $package
    set versions [list]
    foreach v [package versions $package] {
        set script [package ifneeded $package $v]
        set vw [list]
        lappend vw $v
	set nolist [catch {lindex $script 0}]
        if {!$nolist && [lindex $script 0] eq "source"} {
            lappend vw Tcl [lindex $script 1]
        } elseif {!$nolist && [lindex $script 0] eq "load"} {
            lappend vw Binary [lindex $script 1]
        } else {
            lappend vw Unknown
        }
        lappend versions $vw
    }
    my @versions setListUnsorted $versions
    my unselectState
}
IDE::PackageLoader instproc selectVersion version {
    my set selectedVersion $version
    my instvar win
    foreach w {load loadDirect loadWS searchRequirements} {
        $win.buttons.$w configure -state normal
    }
}
IDE::PackageLoader instproc specificInit {} {
    my instvar win
    panedwindow $win.upperarea -orient horizontal

    IDE::NListView create [self]::@packages $win.packages -notify [self] -notifyProc selectPackage -label "package"
    IDE::NListView create [self]::@versions $win.versions -label "Version/Kind/Location" -notify [self] -notifyProc selectVersion

    frame $win.buttons
    button $win.buttons.load -text "Import Package" -command [list [self] loadPackage]
    button $win.buttons.loadDirect -text "Load Package without Import" -command [list [self] loadPackageDirect]
    button $win.buttons.loadWS -text "Load into workspace" -command [list [self] loadIntoWorkspace]
    button $win.buttons.searchRequirements -text "Search Requirements" -command [list [self] searchRequirements]
    pack $win.buttons.load $win.buttons.loadDirect $win.buttons.loadWS $win.buttons.searchRequirements -side left

    $win.upperarea add $win.packages -sticky news
    $win.upperarea add $win.versions -sticky news

    pack $win.upperarea -expand yes -fill both
    pack $win.buttons -fill x

    my initPackages
    next
}
IDE::PackageLoader instproc unselectState {} {
    my instvar win
    foreach w {load loadDirect loadWS searchRequirements} {
        $win.buttons.$w configure -state disabled
    }
}
IDE::PackageLoader proc newBrowser {} {
    my new .packageLoader
}
Class IDE::PreferencesView -superclass {::IDE::Browser ::IDE::GUICommands} -parameter {{atHead 1}}
@ ::IDE::PreferencesView idemeta component IDEView
IDE::PreferencesView instproc applyPreferences {} {
    my instvar changedColor win

    set aconf [font actual textfont_pref]
    if {[IDEPreferences getParameter textfont] ne $aconf} {
        IDEPreferences setParameter textfont $aconf
        eval font configure textfont $aconf
    }
    set aconf [font actual listboxfont_pref]
    if {[IDEPreferences getParameter listboxfont] ne $aconf} {
        IDEPreferences setParameter listboxfont $aconf
        eval font configure listboxfont $aconf
    }
    if {[info exists changedColor(text)]} {
        set color [$win.cframe.text_example cget -background]
        IDEPreferences setParameter textcolor $color
        IDE::Text setColor $color
        unset changedColor(text)
    }
    if {[info exists changedColor(listbox)]} {
        set color [$win.cframe.listbox_example cget -background]
        IDEPreferences setParameter listboxcolor $color
        IDE::ListView setColor $color
        unset changedColor(listbox)
    }
}
IDE::PreferencesView instproc cancelPreferences {} {
    my destroy
}
IDE::PreferencesView instproc changeColor color {
    my instvar win changedColor
    set examplewin $win.cframe.${color}_example
    set c [$examplewin cget -background]
    set ncolor [IDE::Dialog getColor $c]
    if {$ncolor ne ""} {
        set changedColor($color) 1
        $examplewin configure -background $ncolor
    }
}
IDE::PreferencesView instproc changeFont font {
    set fontname ${font}_pref
    set erg [IDE::FontChooser getFont [font actual $fontname]]
    if {$erg ne ""} {
        eval font configure $fontname $erg
    }
}
IDE::PreferencesView instproc createSystemMenu {} {
    my instvar win
    if {[winfo toplevel $win] eq "."} {
        set twin {}
    } else {
        set twin $win
    }
    [winfo toplevel $win] configure -menu $twin.mb
}
IDE::PreferencesView instproc exportPreferences {} {
    set filename [IDE::Dialog getSaveFile xotclide]
    if {$filename ne ""} {
        IDEPreferences savePreferencesAsFile $filename
    }
}
IDE::PreferencesView instproc fillMenuStruct aMenuStruct {
    $aMenuStruct enablementHandler [self]

    $aMenuStruct addCommand {Import Preferences} [list [self] importPreferences]
    $aMenuStruct addCommand {Export Preferences} [list [self] exportPreferences]
}
IDE::PreferencesView instproc getMenuStruct {} {
    IDE::MenuStruct create [self]::ms Preferences 0
}
IDE::PreferencesView instproc getTitle {} {
    return Preferences
}
IDE::PreferencesView instproc importPreferences {} {
    set filename [IDE::Dialog getOpenFile]
    if {$filename ne ""} {
        IDEPreferences loadPreferencesFromFile $filename
        my refreshView
    }
}
IDE::PreferencesView instproc initFonts {} {
    if {[lsearch [font names] textfont_pref]<0} {
        font create textfont_pref
        font create listboxfont_pref
    }
}
IDE::PreferencesView instproc refreshView {} {
    my instvar win oldcolor changedColor
    eval font configure textfont_pref [IDEPreferences getParameter textfont]
    eval font configure listboxfont_pref [IDEPreferences getParameter listboxfont]
    set c [IDEPreferences getParameter textcolor]
    if {[info exists oldcolor(text)] && $oldcolor(text)!=$c} {
        set changedColor(text) 1
    }
    if {$c ne ""} {
        $win.cframe.text_example configure -background $c
    } else {
        $win.cframe.text_example configure -background [IDE::PreferencesView getDefaultColor text]
    }
    set oldcolor(text) $c
    if {[info exists oldcolor(listbox)] && $oldcolor(listbox)!=$c} {
        set changedColor(listbox) 1
    }
    set c [IDEPreferences getParameter listboxcolor]
    if {$c ne ""} {
        $win.cframe.listbox_example configure -background $c
    } else {
        $win.cframe.listbox_example configure -background [IDE::PreferencesView getDefaultColor text]
    }
    set oldcolor(listbox) $c
}
IDE::PreferencesView instproc savePreferences {} {
    IDEPreferences savePreferences
}
IDE::PreferencesView instproc setDefaults {} {
    IDEPreferences setDefaultPreferences
    my refreshView
}
IDE::PreferencesView instproc specificInit {} {
    my instvar win
    set fwin [frame $win.buttons]
    button $fwin.defaults -text "Set Defaults" -command [list [self] setDefaults]
    button $fwin.apply -text "Apply" -command [list [self] applyPreferences]
    button $fwin.save -text "Save" -command [list [self] savePreferences]
    button $fwin.cancel -text "Quit" -command [list [self] cancelPreferences]
    pack $fwin.defaults $fwin.apply $fwin.save $fwin.cancel -side left -anchor e


    frame $win.cframe

    label $win.cframe.eflab -text "Editor Font"
    label $win.cframe.lflab -text "Listview Font"
    my initFonts
    label $win.cframe.efexample  -border 2 -relief sunken -text "Example Text" -font textfont_pref
    label $win.cframe.lfexample  -border 2 -relief sunken -text "Example Text" -font listboxfont_pref
    button $win.cframe.efchange -text "Change" -command [list [self] changeFont textfont]
    button $win.cframe.lfchange -text "Change" -command [list [self] changeFont listboxfont]

    label $win.cframe.eclab -text "Editor Background"
    label $win.cframe.lclab -text "List Background"
    label $win.cframe.text_example  -border 2 -relief sunken
    label $win.cframe.listbox_example  -border 2 -relief sunken
    button $win.cframe.ecchange -text "Change" -command [list [self] changeColor text]
    button $win.cframe.lcchange -text "Change" -command [list [self] changeColor listbox]

    grid $win.cframe.eflab -column 0 -row 0
    grid $win.cframe.lflab -column 0 -row 1
    grid $win.cframe.efexample -column 1 -row 0 -sticky ew
    grid $win.cframe.lfexample -column 1 -row 1 -sticky ew
    grid $win.cframe.efchange -column 2 -row 0
    grid $win.cframe.lfchange -column 2 -row 1

    grid $win.cframe.eclab -column 0 -row 2
    grid $win.cframe.lclab -column 0 -row 3
    grid $win.cframe.text_example -column 1 -row 2 -sticky ew
    grid $win.cframe.listbox_example -column 1 -row 3 -sticky ew
    grid $win.cframe.ecchange -column 2 -row 2
    grid $win.cframe.lcchange -column 2 -row 3

    pack $win.cframe -expand yes -fill both -padx 10 -pady 10
    pack $win.buttons -side bottom -expand yes -anchor e -fill x
    my refreshView
    next
}
IDE::PreferencesView proc getDefaultColor typ {
    my instvar defaults
    if {![info exists defaults($typ)]} {
        set win [listbox .lll1]
        set defaults(listbox) [lindex [$win configure -background] 3]
        ::destroy $win
        set win [text .lll1]
        set defaults(text) [lindex [$win configure -background] 3]
        ::destroy $win
    }
    return $defaults($typ)
}
IDE::PreferencesView proc newBrowser {} {
    if {![Object isobject ::preferencesview]} {
        my create ::preferencesview .preferencesview
    }
}
Class IDE::ProcToMethodWizzard -superclass ::IDE::Browser -parameter procedures
@ ::IDE::ProcToMethodWizzard idemeta component IDEView
IDE::ProcToMethodWizzard instproc actionConvert {} {
    my instvar targetClass procedures convertInnerCalls deleteAfterConvert
    if {$targetClass eq ""} {
        IDE::Dialog error "Choose the target class first"
        return
    }
    set innerMethods [list]
    # procedures are without leading ::
    # add with full namespace name
    foreach p $procedures {
        lappend innerMethods ::$p
    }
    foreach p $procedures {
        lappend innerMethods $p
    }
    foreach p $procedures {
        if {[string first :: $p]>=0} {
            lappend innerMethods [namespace tail $p]
        }
    }

    foreach p $procedures {
        set body [IDE::IntroProxy getBodyTclMethod $p]
        if {$body eq ""} continue
        set method [namespace tail $p]
        if {[$targetClass info instprocs $method] ne ""} continue
        set method_body [lindex $body 3]
        if {$convertInnerCalls} {
            foreach pname $innerMethods {
                regsub -all -line "^(\\s*)$pname\\M" $method_body "\\1my [namespace tail $pname]" method_body
                regsub -all -line "\\\[$pname\\M" $method_body "\[my [namespace tail $pname]" method_body
                # regsub -all "\\m$pname\\M" $method_body "my [namespace tail $pname]" method_body
            }
        }
        namespace eval :: $targetClass instproc $method [list [lindex $body 2]] \{$method_body\}
        if {$deleteAfterConvert} {
            set pobj [IDE::TclProcsDescription getMethodFor $p]
            if {$pobj ne ""} {
                [$pobj getGroupObj] removeMethodObj $pobj
            }
        }
    }
    my destroy
}
IDE::ProcToMethodWizzard instproc chooseClass {} {
    my instvar win targetClass
    set targetClass [IDE::ClassSelector getClass]
    $win.tframe.target configure -text $targetClass
}
IDE::ProcToMethodWizzard instproc createSystemMenu {} {
    # no menu
}
IDE::ProcToMethodWizzard instproc getTitle {} {
    return "Proc-To-Method Converter"
}
IDE::ProcToMethodWizzard instproc specificInit {} {
    my instvar win procedures convertInnerCalls deleteAfterConvert
    my requireNamespace
    set converInnerCalls 0
    set deleteAfterConvert 0

    frame $win.tframe
    frame $win.buttons -relief raised -border 3

    label $win.tframe.target -border 2 -width 40 -relief sunken -anchor w
    button $win.tframe.change -text "Choose Class" -command [list [self] chooseClass]
    pack $win.tframe.target $win.tframe.change -side left

    checkbutton $win.convertInnerCalls -text "replace inner calls to self invokation" -variable [self]::convertInnerCalls
    checkbutton $win.deleteAfterConverting -text "delete procs after converting" -variable [self]::deleteAfterConvert

    ::message $win.msg  -width 350 -text "Please use syntax checker to find all incompatible calls and variable references after converting. This tool do not work full automatic the converted methods must be manuelly adapted. (delete the the Tcl procedures before syntax check)" -padx 10 -pady 10

    button $win.buttons.ok -text "Convert Procedures" -command [list [self] actionConvert]
    button $win.buttons.cancel -text "Cancel" -command "destroy $win; [self] destroy" -underline 0

    pack $win.buttons.ok $win.buttons.cancel -side left

    pack $win.tframe -fill x -expand yes
    pack $win.convertInnerCalls -anchor w
    pack $win.deleteAfterConverting -anchor w
    pack $win.msg
    pack $win.buttons -anchor w -ipady 10 -ipadx 6 -fill x

    set cancelscript "
               $win.buttons.cancel configure -state active -relief sunken
               update idletasks
               after 100
               $win.buttons.cancel invoke"

    bind $win <Escape> $cancelscript
    bind $win <Alt-c> $cancelscript

    next
}
IDE::ProcToMethodWizzard proc convertProcedures procs {
    my new [Object autoname .procconverter] [list -procedures $procs]
}
Class IDE::ProtBrowser -superclass ::IDE::Browser
@ ::IDE::ProtBrowser idemeta component IDEView
IDE::ProtBrowser instproc append text {
    [self]::prottext append $text
}
IDE::ProtBrowser instproc specificInit {} {
    my instvar win
    IDE::ProtocolText [self]::prottext $win.resulttext

    grid $win.resulttext -row 0 -column 0 -sticky news

    grid columnconfigure $win 0 -weight 1
    grid rowconfigure $win 0 -weight 1
    next
}
IDE::ProtBrowser proc newBrowser {} {
    return [my new [Object autoname .protbrowser]]
}
Class IDE::ResultBrowser -superclass ::IDE::Browser -parameter result
@ ::IDE::ResultBrowser idemeta component IDEView
IDE::ResultBrowser instproc getTitle {} {
    return {Result Browser}
}
IDE::ResultBrowser instproc setResult text {
    [self]::resulttext setText $text
}
IDE::ResultBrowser instproc specificInit {} {
    my instvar win result
    IDE::Editor [self]::resulttext $win.resulttext

    grid $win.resulttext -row 0 -column 0 -sticky news

    grid columnconfigure $win 0 -weight 1
    grid rowconfigure $win 0 -weight 1

    my setResult [my result]
    next
}
IDE::ResultBrowser proc newBrowser result {
    return [my new [Object autoname .result] [list -result $result]]
}
Class IDE::SpawnMethodEdit -superclass ::IDE::Browser
@ ::IDE::SpawnMethodEdit idemeta component IDEView
IDE::SpawnMethodEdit instproc createSystemMenu {} {
    next
    my instvar win
    if {[winfo toplevel $win] eq "."} {
        set twin {}
    } else {
        set twin $win
    }
    $twin.mb add command -label "Invoke" -command [list [self] invoke]
}
IDE::SpawnMethodEdit instproc getTitle {} {
    return {Spawned Method Edit}
}
IDE::SpawnMethodEdit instproc invoke {} {
    set text [[self]::methodedit getText]
    if { [lindex $text 0] == "proc" } {
        IDE::System invokeTclProc [lindex $text 1]
    } else {
        set type [lindex $text 0]
        if { [Object isclass $type] } {
            switch [lindex $text 1] {
                "instproc" {
                    error "Can not direct call instance proc."
                }
                "proc" {
                    IDE::System invokeProc $type [lindex $text 2]
                }
                default {
                    error "Unknown method type to call."
                }
            }
        } else {
            error "Can call only proc or class proc."
        }
    }
}
IDE::SpawnMethodEdit instproc specificInit {} {
    my instvar win
    IDE::TclModeEdit [self]::methodedit $win.methodedit
    pack $win.methodedit -fill both -expand yes
}
Class IDE::SubObjectsView -superclass {::IDE::HListView ::IDE::GUICommands} -parameter {{label Subobjects}}
@ ::IDE::SubObjectsView idemeta component IDEView
IDE::SubObjectsView instproc askForItemChange {} {
    [my info parent]::methodedit askForModification
}
IDE::SubObjectsView instproc fillMenuStruct ms {
    $ms enablementHandler [self]
    
    $ms addCommand2 {Inspect in new window} [list [self] inspectObject] isValidSelection
    $ms addCommand2 {Inspect in this window} [list [self] inspectObjectInThis] isValidSelection
    $ms addCommand2 {Inspect Parent} [list [my info parent] inspectParent] isValidParent
    $ms addCommand2 {Refresh} [list [self] refresh] hasObject
    next
}
IDE::SubObjectsView instproc getMenuStruct {} {
    IDE::MenuStruct create [self]::ms Subobjects 4
}
IDE::SubObjectsView instproc hasObject {} {
    expr {[my set vobject] ne ""}
}
IDE::SubObjectsView instproc inspectObject {} {
    set actual [my selectionAsObject]
    if {$actual eq ""} return
    $actual inspect
}
IDE::SubObjectsView instproc inspectObjectInThis {} {
    set actual [my selectionAsObject]
    if {$actual eq ""} return
    [my info parent] setViewObject $actual
}
IDE::SubObjectsView instproc isValidParent {} {
    my instvar vobject
    expr {$vobject ne "" && [set parent [$vobject info parent]] ne "::" && [Object isobject $parent]}
}
IDE::SubObjectsView instproc refresh {} {
    my instvar vobject
    my setHList [lrange [$vobject getSubobjectsHierarchy] 1 end]
    my selectItem {}
}
IDE::SubObjectsView instproc selectFor object {
    my instvar vobject
    set vobject $object
    if {$vobject eq ""} {
        my resetList
        return
    }
    my setHList [lrange [$vobject getSubobjectsHierarchy] 1 end]
    my selectItem {}
}
IDE::SubObjectsView instproc selectItem object {
    set object [my selectionAsObject]
    if {$object eq ""} return
    if {[Object isobject [my info parent]::methodedit]} {
        [my info parent]::methodedit setTextControler [$object printString] [self]
    }
}
IDE::SubObjectsView instproc selectionAsObject {} {
    my instvar objlist
    set index [my selectedIndex]
    if {$index eq ""} return
    return [lindex $objlist $index]
}
IDE::SubObjectsView instproc setList list {
    my instvar objlist
    set translist {}
    set objlist {}
    foreach elem $list {
        lappend objlist [string trimleft $elem]
        set pre {}
        regexp { +} $elem pre
        lappend translist "$pre[namespace tail [string trimleft $elem]]"
    }
    next $translist
}
Class IDE::SyntaxCheckMethodList -superclass {::IDE::NListView ::IDE::GUICommands}
@ ::IDE::SyntaxCheckMethodList idemeta component IDEView
IDE::SyntaxCheckMethodList instproc browseChildren actual {
    set item [split $actual >]
    set vclass [lindex [lindex $item 0] 0]
    if {[Object isclass $vclass]} {
        IDE::HeritageBrowser newBrowserChild $vclass
    } else {
        my upsMessage "$vclass is not a class"
    }
}
IDE::SyntaxCheckMethodList instproc browseHeritage actual {
    set item [split $actual >]
    set vclass [lindex [lindex $item 0] 0]
    if {[Object isclass $vclass]} {
        IDE::HeritageBrowser newBrowser $vclass
    } else {
        my upsMessage "$vclass is not a class"
    }
}
IDE::SyntaxCheckMethodList instproc fillMenuStruct ms {
    $ms enablementHandler [self]
    $ms addCommand2 {Remove from List} [list [self] dispatchWithSelected removeMethod] isValidSelection
    $ms addCommand2 {Heritage Browser} [list [self] dispatchWithSelected browseHeritage] isValidSelection
    $ms addCommand2 {Children Browser} [list [self] dispatchWithSelected browseChildren] isValidSelection
    $ms addCommand2 {Search Senders} [list [self] dispatchWithSelected searchSenders] isValidSelection
    my menuInsertions $ms
    next
}
IDE::SyntaxCheckMethodList instproc getMenuStruct {} {
    IDE::MenuStruct create [self]::ms Methods 0
}
IDE::SyntaxCheckMethodList instproc removeMethod actual {
    [my info parent] removeMethod
}
IDE::SyntaxCheckMethodList instproc searchSenders actual {
    set method [lindex [split $actual >] 1]
    IDE::MethodBrowser searchSendersAll $method
}
Class IDE::SyntaxChecker -superclass {::IDE::Browser ::IDE::GUICommands} -parameter {{atHead 1}}
@ ::IDE::SyntaxChecker idemeta categories {initialize viewing}
@ ::IDE::SyntaxChecker idemeta categoriesMethods {{getTitle fillMenuStruct getMenuStruct specificInit} {selectMethod selectError}}
@ ::IDE::SyntaxChecker idemeta component IDEView
IDE::SyntaxChecker instproc checkComponents {} {
    my instvar errorsArr
    set components [[self]::components selectedItem]
    if {$components eq ""} {
        IDE::Dialog message "No componets selected"
        return
    }
    catch {unset errorsArr}
    [self]::messages setList {}
    set c 0
    set report [time {
        foreach component $components {
            set cobj [IDE::Component getCompObjectForNameIfExist $component]
            foreach cls [$cobj getClasses] {
                foreach method [$cls info instprocs] {
                    set chk [PrsContext new]
                    $chk parseAndCheck [IDE::IntroProxy getBodyInstanceMethod $cls $method]
                    my setStateText "$cls [incr c]"
                    if {[$chk hasErrors]} {
                        set errorsArr($cls>$method) [$chk errors]
                    }
                    $chk destroy
                    update
                }
                foreach method [$cls info procs] {
                    set chk [PrsContext new]
                    $chk parseAndCheck [IDE::IntroProxy getBodyClassMethod $cls $method]
                    my setStateText "$cls [incr c]"
                    if {[$chk hasErrors]} {
                        set errorsArr($cls\ class>$method) [$chk errors]
                    }
                    $chk destroy
                    update
                }
            }
            foreach obj [$cobj getObjects] {
                foreach method [$obj info procs] {
                    if {$method eq "-"} continue
                    set chk [PrsContext new]
                    $chk parseAndCheck [IDE::IntroProxy getBodyClassMethod $obj $method]
                    my setStateText "$obj [incr c]"
                    if {[$chk hasErrors]} {
                        set errorsArr($obj\ class>$method) [$chk errors]
                    }
                    $chk destroy
                    update
                }
            }
            foreach gobj [$cobj getProcsGroupsObjects] {
                foreach method [$gobj getProcsNames] {
                    set chk [PrsContext new]
                    $chk parseAndCheck [IDE::IntroProxy getProcBody $method]
                    my setStateText "procs [incr c]"
                    if {[$chk hasErrors]} {
                        set errorsArr(proc\ $method) [$chk errors]
                    }
                    $chk destroy
                    update
                }
            }
        }
    }]
    my setStateText "$report $c methods"
    my setListViews
}
IDE::SyntaxChecker instproc excludeIDE {} {
    set idecore [concat [IDE::System getCoreComponentsAll] [IDE::System getExtraComponents]]
    foreach index [[self]::components selectedIndex] item [[self]::components selectedItem] {
        if {[ide::lcontain $idecore $item]} {
            [self]::components removeSelection $index $index
        }
    }
}
IDE::SyntaxChecker instproc fillMenuStruct aMenuStruct {
    $aMenuStruct addCommand {Protokoll to File} [list [self] protokollToFile]
}
IDE::SyntaxChecker instproc getBodyForItem item {
    if {[lindex $item 0] eq "proc"} {
        return [IDE::IntroProxy getProcBody [lindex $item 1]]
    } else {
        set item [split $item >]
        set method [lindex $item 1]
        set vtype [lindex [lindex $item 0] 1]
        if {$vtype eq ""} { set vtype Instance} else { set vtype Class}
        set vclass [lindex [lindex $item 0] 0]
        return [IDE::IntroProxy getBody${vtype}Method $vclass $method]
    }
}
IDE::SyntaxChecker instproc getMenuStruct {} {
    IDE::MenuStruct create [self]::ms {Syntax Check} 0
}
IDE::SyntaxChecker instproc getTitle {} {
    return {Syntax Checker Browser}
}
IDE::SyntaxChecker instproc protokollToFile args {
    my instvar errorsArr
    if {![array exists errorsArr]} {
        IDE::Dialog message "No errors to protokoll. Run a checker first"
        return
    }
    set file [IDE::Dialog getSaveFile errors.txt]
    if {$file eq ""} return
    set pfile [open $file w]
    for {set sid [array startsearch errorsArr]} {[array anymore errorsArr $sid]} {} {
        set method [array nextelement errorsArr $sid]
        set errors $errorsArr($method)
        set char 0
        set index 0
        set end 0
        foreach line [split [my getBodyForItem $method] \n] {
            puts $pfile $line
            incr char [string length $line]
            incr char
            if {!$end && $char>[lindex [lindex $errors $index] 0]} {
                puts $pfile "-----> [lindex [lindex $errors $index] 2]"
                incr index
                if {$index>=[llength $errors]} {
                    set end 1
                }
            }
        }
    }
    array donesearch errorsArr $sid
    close $pfile
}
IDE::SyntaxChecker instproc readComponents {} {
    [self]::components setList [IDE::IntroProxy getComponents]
}
IDE::SyntaxChecker instproc removeMethod {} {
    my instvar errorsArr
    set item [[self]::methods selectedItem]
    if {$item eq ""} return
    if {[array exists errorsArr]} {
        unset errorsArr($item)
        my setListViews
    }
}
IDE::SyntaxChecker instproc selectAll {} {
    [self]::components addSelection 0 end
}
IDE::SyntaxChecker instproc selectError item {
    set index [[self]::messages selectedIndex]
    set error [lindex [my set errors] $index]
    [self]::body removeColorize
    [self]::body colorizeRange [lindex $error 0] [expr {[lindex $error 1]+1}]
    [self]::body viewPos [lindex $error 0]

}
IDE::SyntaxChecker instproc selectMethod item {
    my instvar errors errorsArr
    set errors $errorsArr($item)
    [self]::body setTextType [my getBodyForItem $item] xotcl
    [self]::messages setListUnsorted [ide::lcollect each $errors {lindex $each 2}]
    # !!! no save controller
}
IDE::SyntaxChecker instproc setListViews {} {
    my instvar errorsArr
    if {[array exists errorsArr]} {
        [self]::methods setList [array names errorsArr]
    } else {
        [self]::methods setList {}
    }
    [self]::messages setListUnsorted {}
}
IDE::SyntaxChecker instproc setStateText text {
    my setStatusBarText $text
    update idletasks
}
IDE::SyntaxChecker instproc specificInit {} {
    my instvar win

    set panned [IDE::System isTkNeverThan84]

    if {$panned} {
        panedwindow $win.panedwindow -orient vertical
        set topwin [panedwindow $win.upperarea -orient horizontal]
    } else {
        set topwin [frame $win.sel]
    }
    set mainframe [frame $win.mframe]
    set bframe [frame $mainframe.bframe]

    IDE::ListView create [self]::components $topwin.components -multiselect 1 -label "Components Alt-1"
    IDE::SyntaxCheckMethodList create [self]::methods $topwin.methods -notify [self] -notifyProc selectMethod -width 45 -label "Methods Alt-2"
    IDE::NListView create [self]::messages $topwin.messages -notify [self] -notifyProc selectError -width 40 -label "Errors Alt-3 (Alt-n/p next/prev)"

    button $bframe.check -text "Check Selected" -underline 0 -command [list [self] checkComponents]
    button $bframe.all -text "Select All Components" -underline 7 -command [list [self] selectAll]
    button $bframe.allTcl -text "Exclude IDE Components" -underline 1 -command [list [self] excludeIDE]

    IDE::TclModeEdit [self]::body $mainframe.body -mixin IDE::CodeController

    pack $bframe.check $bframe.all $bframe.allTcl -side left -anchor nw
    pack $bframe -side top -anchor nw -fill x
    pack $mainframe.body -fill both -side bottom -expand 1

    if {$panned} {
        $topwin add $topwin.components $topwin.methods $topwin.messages -width 200
        $win.panedwindow add $topwin -sticky news -height  160
        $win.panedwindow add $mainframe -sticky news -height 260
        pack $win.panedwindow -expand yes -fill both
    } else {
        pack $topwin.components $topwin.methods $topwin.messages -side left -expand 1 -fill both
        pack $topwin -anchor w -expand 0 -fill x
        pack $mainframe -anchor w -expand 1 -fill both
    }

    bind $win <Alt-a> [list [self] selectAll]
    bind $win <Alt-c> [list [self] checkComponents]
    bind $win <Alt-x> [list [self] excludeIDE]
    bind $win <Alt-p> [list [self]::messages selectPrevItem]
    bind $win <Alt-n> [list [self]::messages selectNextItem]

    bind $win <Alt-KeyPress-1> [list focus [[self]::components getFocusWin]]
    bind $win <Alt-KeyPress-2> [list focus [[self]::methods getFocusWin]]
    bind $win <Alt-KeyPress-3> [list focus [[self]::messages getFocusWin]]

    my readComponents

    focus [[self]::components getFocusWin]

    next

    my initStatusBar -1
    my setStatusBarText "This tool check the syntax in selected components"
}
IDE::SyntaxChecker proc newBrowser {} {
    return [my new [Object autoname .syntax]]
}
Class IDE::SyntaxErrorView -superclass ::IDE::Browser -parameter {errors editor controler}
@ ::IDE::SyntaxErrorView idemeta component IDEView
IDE::SyntaxErrorView instproc createSystemMenu {} {
    # no system menu
}
IDE::SyntaxErrorView instproc destroy {} {
    if {[Object isobject [my editor]]} {
        [my editor] dropAllColorized
    }
    next
}
IDE::SyntaxErrorView instproc forceSaving {} {
    [my editor] saveForce
    my destroy
}
IDE::SyntaxErrorView instproc getTitle {} {
    return {Syntax Errors}
}
IDE::SyntaxErrorView instproc selectError item {

    set index [[self]::errorlist selectedIndex]
    set error [lindex [my errors] $index]
    [my editor] colorizeRange [lindex $error 0] [expr {[lindex $error 1]+1}]
    [my editor] viewPos [lindex $error 0]
}
IDE::SyntaxErrorView instproc specificInit {} {
    my instvar win

    message $win.message -text {Found possible syntax error(s)! If you want to prevent checking in this method place magic text "no syntax check" in it.} -width 350

    IDE::NListView [self]::errorlist $win.errorlist -notify [self] -notifyProc selectError -height 15 -width 50

    frame $win.buttons
    button $win.buttons.cancel -text "Cancel Saving (Esc)" -command [list [self] destroy]
    button $win.buttons.force -text "Force Saving (Enter)" -default active -command [list [self] forceSaving]
    set cancelscript "
               $win.buttons.cancel configure -state active -relief sunken
               update idletasks
               after 100
               [self] destroy"
    set okscript "
               $win.buttons.force configure -state active -relief sunken
               update idletasks
               after 100
               [self] forceSaving
               break"
    bind $win <KeyRelease-Return> $okscript
    bind $win <Escape> $cancelscript
    bind $win <Alt-n> [list [self]::errorlist selectNextItem]
    bind $win <Alt-p> [list [self]::errorlist selectPrevItem]

    pack $win.message  -anchor w -expand yes -fill x
    pack $win.errorlist -fill both -expand yes
    pack $win.buttons -anchor w
    pack $win.buttons.cancel $win.buttons.force -side left
    [self]::errorlist setListUnsorted [ide::lcollect each [my errors] {lindex $each 2}]
    focus $win
    next
}
Class IDE::TclGroupDefinition -superclass ::IDE::Browser -parameter {classView {mode define}}
@ ::IDE::TclGroupDefinition idemeta component IDEView
IDE::TclGroupDefinition instproc actionCreate {} {
    my instvar isnamespace groupName classView
    if {[my checkClassView]} {
        if {[my mode] eq "redefine"} {
            # !!!
        } else {
            if {![my getValuesFromGUI]} return
            $classView createTclProcsGroup $groupName $isnamespace
        }
    }
    my destroy
}
IDE::TclGroupDefinition instproc checkClassView {} {
    my instvar classView
    return [Object isobject $classView]
}
IDE::TclGroupDefinition instproc createSystemMenu {} {
    # no system menu
}
IDE::TclGroupDefinition instproc destroy {} {
    my instvar win
    ::destroy $win
    next
}
IDE::TclGroupDefinition instproc getTitle {} {
    return {Tcl-Proc-Group Definition}
}
IDE::TclGroupDefinition instproc getValuesFromGUI {} {
    my instvar win groupName
    set groupName [$win.fname.name get]
    if {$groupName eq ""} {
        IDE::Dialog error "You must specify new name for the tcl group"
        return 0
    }
    return 1
}
IDE::TclGroupDefinition instproc specificInit {} {
    my instvar win

    frame $win.buttons -relief raised -border 3
    frame $win.fname

    message $win.message -text {Give new name for tcl procs group} -width 250
    label $win.fname.lname -text Name
    entry $win.fname.name

    my requireNamespace
    checkbutton $win.isnamespace -text "use name as Tcl namespace" -variable [self]::isnamespace

    button $win.buttons.ok -text Create -command [list [self] actionCreate]
    button $win.buttons.cancel -text Cancel -command "destroy $win; [self] destroy"
    pack $win.buttons.ok $win.buttons.cancel -side left
    pack $win.fname.lname $win.fname.name -side left
    pack $win.message
    pack $win.fname -anchor w
    pack $win.isnamespace -anchor w
    pack $win.buttons -anchor w -ipady 10 -ipadx 6 -fill x

    next
}
IDE::TclGroupDefinition proc newGroup view {
    return [my new [Object autoname .tgdbrowser] -classView $view]
}
IDE::TclGroupDefinition proc unknown args {
    error "unknown method on [self] $args"
}
Class IDE::Transcript -superclass ::IDE::Browser
@ ::IDE::Transcript idemeta component IDEView
IDE::Transcript instproc destroy {} {
    next
}
IDE::Transcript instproc getTitle {} {
    if {[self] eq "::transcript"} {
        return Transcript
    } else {
        return Workspace
    }
}
IDE::Transcript instproc log string {
    my @editor appendToCursor $string
}
IDE::Transcript instproc specificInit args {
    my instvar win

    IDE::EditorTranscript [self]::@editor $win.editor
    global tcl_patchLevel
    if {$win eq ".f"} {
        wm protocol [winfo toplevel $win] WM_DELETE_WINDOW [list IDE::System exitIDEGUI]
        $win.editor.text insert 0.1 "Artur Trzewik 2001 all rights reserved\nXOTclIDE Version [IDE::System getVersion] 12.2006\nInteractive Developing System for Tcl $tcl_patchLevel / XOTcl [set xotcl::version][set xotcl::patchlevel]\nGNU Public License Software\nXOTclIDE comes with ABSOLUTELY NO WARRANTY See the GNU General Public License for more details.\n\nREADY"
    }
    pack $win.editor -side bottom -expand yes -fill both

    next
}
IDE::Transcript instproc warning string {
    my @editor appendToCursor "\n$string"
}
IDE::Transcript proc buildMain {} {
    if {[Object isobject ::transcript]} {
        return
    }
    frame .f
    pack .f -fill both -expand yes
    my create ::transcript .f
}
IDE::Transcript proc newBrowser {} {
    return [my new [Object autoname .workspace]]
}
IDE::Transcript proc openFile file {
    set w [my newBrowser]
    ${w}::editor openFile $file
}
IDE::Transcript proc warning string {
    if {[Object isobject ::transcript]} {
        ::transcript warning $string
    }
}
@ Object IDE::PlugInsManager {
description {# PlugIns List Format

Name Label Component Startscript DepComponent}
}
Object IDE::PlugInsManager
@ ::IDE::PlugInsManager idemeta component IDEView
IDE::PlugInsManager proc getMenuStruct ms {
    my instvar plugInsArr plugInsList
    if {![info exists plugInsArr]} return
    IDE::MenuStruct create ${ms}::extras {Plug Ins}
    $ms addCascadeMenu ${ms}::extras
    foreach key $plugInsList {
        set value $plugInsArr($key)
        set label [lindex $value 1]
        ${ms}::extras addCommand $label [list [self] loadExtras $key]
    }
}
IDE::PlugInsManager proc loadExtras extra {
   my instvar plugInsArr plugInsList
   if {![ide::lcontain $plugInsList $extra]} {
       error "$extra is not registered plug in"
   }
   foreach {Name Label Component Startscript DepPlugInsList} $plugInsArr($extra) {}
   foreach dep $DepPlugInsList {my loadExtras $dep}
   IDE::SystemConfigMap loadComponentFromAny $Component
   namespace eval :: $Startscript
}
IDE::PlugInsManager proc readPlugInsList {{file {}}} {
    my instvar plugInsArr plugInsList
    if {$file eq ""} {
        set file [file join [IDE::System getSystemDir] pluginslist.txt]
    }
    if {![file exists $file]} return
    set fh [open $file r]
    while {[gets $fh line]>=0} {
        if {[string match #* $line] || $line eq ""} continue
        lappend plugInsList [lindex $line 0]
        set plugInsArr([lindex $line 0]) $line
    }
    close $fh
}
@ Object IDE::System {
description {This object held the system generic methods as
1. quering envirorments parameters (directory, user)
2. specify systems menu
3. quering systems constants
4. evaluate user scripts
}
}
Object IDE::System
@ ::IDE::System idemeta categoriesMethodsProcs {{signalComponentsChanged exitIDEGUI inspectString versionAllCoreComponents loadExtras showFreshMethods} {getUserId getSystemDir getCoreComponentsAll getXotclPackages isTkNeverThan84 getCoreComponents getExtraComponents getVersion getMenuStruct} {handleResult tryBrowseAsObjectList invokeProc invokeTclProc invokeInstproc createInstance invokeProcWithArg} {evalString evalInspectString substituteString browseString invokeTclProcWithArg} {initDatabase initDatabaseNoConnect initializeAfterLoad} {isDatabase showBusyWhile}}
@ ::IDE::System idemeta categoriesProcs {actions system-constans invoke-action eval-action initializing service}
@ ::IDE::System idemeta component IDEView
IDE::System proc browseString string {
    if {[Object isclass $string]} {
        IDE::HeritageBrowser newBrowser $string
    } elseif {[Object isobject $string]} {
        IDE::ObjectBrowser newBrowser $string
    } else {
       if {[my tryBrowseAsObjectList $string]} return
       if {![IDE::MethodBrowser searchImplementorsAll $string 1]} {
           IDE::Dialog message "$string is not a Class, Object (Objects list) or method name"
        }
    }
}
IDE::System proc createInstance class {
    if {![Object isclass $class]} { error "$class is not Xotcl Class"}
    set arguments {}
    if {[$class info instprocs init] ne ""} {
        foreach arg [$class info instargs init] {
           if {[$class info instdefault init $arg val]} {
              lappend arguments [list $arg $val]
              } else {
              lappend arguments $arg 
           }
        }
    }
    set parameters {}
    foreach par [$class info parameter] {
         lappend parameters [lindex $par 0]
    }
    set ret [IDE::IDialogEntry getValueWithCancel "Create instance of $class\n$arguments\n$parameters"]
    if {$ret eq "_cancel"} return
    if {$ret ne ""} {
       return [namespace eval :: $class create [Object autoname sample] $ret]
    } else {
       return [namespace eval :: [list $class create [Object autoname sample]]]
    }
}
IDE::System proc evalInspectString string {
    set res [my evalString $string]
    my inspectString $res
}
IDE::System proc evalString string {
     namespace eval :: $string
}
IDE::System proc exitIDEGUI {} {
    if {[IDE::Dialog yesNo {Do you want to exit XOTclIDE?}]} {
         exit
    }
}
IDE::System proc getCoreComponents {} {
  list IDEStart IDECore IDEBaseGUI IDEPersistenceGUI IDEView xdobry::mysql xdobry::sql xdobry::pgsql xdobry::odbc xdobry::sqlite xdobry::access xdobry::mssql xdobry::oratcl xometakit IDEPersistence IDEEditor IDEDebug IDEPersistenceAdd IDEErrorReporter IDETclParser
}
IDE::System proc getCoreComponentsAll {} {
  return [concat [my getCoreComponents] core default]
}
IDE::System proc getExtraComponents {} {
    list IDETestFramework IDETests IDEVCInstaller IDEDocumentation IDEConfiguration IDEPersistenceTests xdobry::sqlDebug IDEWikiReaper IDEKitDeployer IDEScriptEditor IDERepositoryImporter IDETkWinInspector IDESQLBrowser IDEFileBrowser IDERegexpBrowser IDEInternationalizationHelper IDEUpdater
}
IDE::System proc getMenuStruct {} {
    set mobj [self]::ms
    if {[Object isobject $mobj]} {
        return $mobj
    }
    set ms [IDE::MenuStruct create $mobj System 0]
    $ms addMenuItem [IDE::MenuCommand new -childof $mobj -accelerator {F5} -name {Component Browser} -command [list IDE::CompBrowser newBrowser]]
    $ms addCommand {Global Vars Inspector} [list IDE::GlobalVarsInspector startBrowser]
    $ms addCommand {Heritage Browser} [list IDE::HeritageBrowser newBrowser]
    $ms addCommand {Syntax Checker} [list IDE::SyntaxChecker newBrowser]
    $ms addCommand {Workspace} [list IDE::Transcript newBrowser]
    $ms addCommand {Configuration Map Browser}  [list IDE::ConfigurationBrowser showBrowser]
    $ms addCommand {Method Tracker Browser} [list IDE::TrackerBrowser openBrowser]
    $ms addCommand {Variable Tracker Browser} [list IDE::VarsTracker newBrowser]
    $ms addCommand {Coverage Analyse Browser} [list IDE::CallingCoverBrowser newBrowser]
    $ms addCommand {Preferences} [list IDE::PreferencesView newBrowser]
    $ms addCommand {Breakpoints Browser} [list IDE::BreakpointsBrowser newBrowser]
    $ms addCheckButton {Enable Breakpoints} IDE::Debugger::shouldHalt {}
    $ms addCheckButton {Ignore IDE Comp.} [self]::ignoreIDE {}
    global tcl_platform
    if {[my isWindowsPlatform]} {
        $ms addCommand {Tcl Console} [list console show]
    }
    IDE::MenuStruct ${ms}::help {Help (external links)}
    $ms addCascadeMenu ${ms}::help
    ${ms}::help addCommand {Tcl/Tk Homepage} [list IDE::System openHTMLBrowser {http://www.tcl.tk}]
    ${ms}::help addCommand {XOTcl Manual} [list IDE::System openHTMLBrowser {http://www.xotcl.org/xotclide/}]
    ${ms}::help addCommand {XOTclIDE Manual} [list IDE::System openHTMLBrowser {http://www.xdobry.de/xotclIDE/docs}]
    ${ms}::help addCommand {Tcl/Tk Wiki} [list IDE::System openHTMLBrowser {http://mini.net/tcl}]
    ${ms}::help addCommand {XOTclIDE on Wiki} [list IDE::System openHTMLBrowser {http://mini.net/tcl/2131}]

    $ms addSeparator

    $ms addCommand {Inspect All Objects} [list IDE::ObjectBrowser browseAllObjects]
    $ms addCommand {Inspect All Object Instances} [list IDE::ObjectBrowser browseAllObjectInstances]
    $ms addCommand {Search Implementors} [list IDE::MethodBrowser searchImplementorsDialog]
    $ms addCommand {Search Breakpoints} [list IDE::MethodBrowser searchBreakPoints]
    IDE::PlugInsManager getMenuStruct $ms
    if {[my isDatabase]} {
       IDE::MenuStruct ${ms}::vcontrol {Version Control}
       $ms addCascadeMenu ${ms}::vcontrol
       ${ms}::vcontrol addCommand {Show Fresh Methods} [list [self] showFreshMethods]
       ${ms}::vcontrol addCommand {Sql Monitor} [list [self] loadExtras sqlDebuger]
       ${ms}::vcontrol addCommand {Configuration Browser} [list [self] loadExtras Configuration]
    }
    $ms addSeparator
    $ms addCommand "Quit XOTclIDE" [list IDE::System exitIDEGUI]
    return $ms
}
IDE::System proc getSystemDir {} {
      global xotclidedir
      return $xotclidedir
}
IDE::System proc getUserId {} {
    IDE::User getDefaultUserId
}
IDE::System proc getVersion {} {
    return 0.81
}
IDE::System proc getXotclPackages {} {
 # I dont know any method to request the available xotcl packages
 return [split {xotcl::awo::htmlPlace
xotcl::awo::secureHtmlPlace
xotcl::awo::userMgt
xotcl::awo::webAgent
xotcl::awo::webDocument
xotcl::comm::connection
xotcl::comm::dav
xotcl::comm::ftp
xotcl::comm::httpAccess
xotcl::comm::httpd
xotcl::comm::imap
xotcl::comm::ldap
xotcl::comm::mime
xotcl::comm::pcache
xotcl::htmllib
xotcl::metadataAnalyzer
xotcl::mixinStrategy
xotcl::mos::agent
xotcl::mos::agentManagement
xotcl::mos::httpPlace
xotcl::mos::invoker
xotcl::mos::placeAccessControl
xotcl::mos::secureHttpPlace
xotcl::mos::sendStrategy
xotcl::mos::webObject
xotcl::package
xotcl::pattern::adapter
xotcl::pattern::chainOfResponsibility
xotcl::pattern::composite
xotcl::pattern::link
xotcl::pattern::manager
xotcl::pattern::observer
xotcl::pattern::onCalleeProxy
xotcl::pattern::singleton
xotcl::pattern::sortedCompositeWithAfter
xotcl::rdf::parser
xotcl::rdf::recreatorVisitor
xotcl::rdf::triple
xotcl::rdf::tripleRecreator
xotcl::registry::registry
xotcl::script
xotcl::scriptCreation::recoveryPoint
xotcl::scriptCreation::scriptCreator
xotcl::scriptCreation::serializer
xotcl::staticMetadataAnalyzer
xotcl::store
xotcl::store::gdbm
xotcl::store::jufgdbm
xotcl::store::mem
xotcl::store::persistence
xotcl::store::sdbm
xotcl::store::tclgdbm
xotcl::store::textfile
xotcl::store::trace
xotcl::trace
xotcl::wafecompat
xotcl::xml::parser
xotcl::xml::printVisitor
xotcl::xml::recreatorVisitor
xotcl::xodoc}]
}
IDE::System proc handleResult result {
   IDE::ResultBrowser newBrowser $result
}
IDE::System proc ignoreIDEComponents switch {
    my set ignoreIDE $switch
}
IDE::System proc initDatabase {} {
   my instvar isDatabase
   IDEPreferences loadPreferences
   IDE::DBPersistence connect
   IDE::User initDefault
   set isDatabase 1
}
IDE::System proc initDatabaseNoConnect {} {
   my instvar isDatabase
   IDE::DBPersistence initSchema
   IDE::User initDefault
   set isDatabase 1
}
IDE::System proc initializeAfterLoad {} {
    my set ignoreIDE 0
    my requireNamespace
}
IDE::System proc inspectString res {
    if {$res eq ""} {
         IDE::Dialog message "No result"
    } elseif {[Object isobject $res]} {
        $res inspect
    } else {
       if {[my tryBrowseAsObjectList $res]} return
       my handleResult $res
    }
}
IDE::System proc invokeInstproc {object instproc} {
    if {![Object isobject $object] || ![Object isclass [$object info class]]} return   
    set arguments [list]
    set defcount 0
    set p [$object procsearch $instproc]
    set class [lindex $p 0]
    foreach arg [$class info instargs $instproc] {
        if {[$class info instdefault $instproc $arg val]} {
            incr defcount 
            lappend arguments [list $arg $val]
        } else {
            lappend arguments $arg 
        }
    }
    if {$::xotcl::version>=1.3} {
       my invokeProcWithArg $object $instproc $arguments $defcount [$class info instnonposargs $instproc]
    } else {
       my invokeProcWithArg $object $instproc $arguments $defcount
    }
}
IDE::System proc invokeProc {object proc} {
    if {![Object isobject $object]} return   
    set arguments {}
    set defarguments 0
    foreach arg [$object info args $proc] {
        if {[$object info default $proc $arg val]} {
            lappend arguments [list $arg $val]
            incr defarguments
        } else {
            lappend arguments $arg 
        }
    }
    my invokeProcWithArg $object $proc $arguments $defarguments
}
IDE::System proc invokeProcWithArg {object proc arg {defargumentsCount 0} {noposarg {}}} {
    if {$arg eq ""} {
       set r [$object $proc]
    } else {
       while 1 {
          set ret [IDE::IDialogEntry getValueWithCancel "$object $proc\ngive the parameter list\n$arg"]
          if {$ret eq "_cancel"} return
          # no check by nopos arguments TODO
          if {$noposarg ne ""} break
          if {[lindex $arg end] eq "args" && [llength $ret]>=[llength $arg]-1-$defargumentsCount} break
          if {[llength $ret]<=[llength $arg] && [llength $ret]>=[llength $arg]-$defargumentsCount} break
          IDE::Dialog message {Wrong length of param list}
       }
       set r [namespace eval :: $object $proc $ret]
    }
    if {$r eq ""} {
        IDE::Dialog message "empty result from $object $proc \n args :[string range $r 0 30]"
     } else {
        my inspectString $r
     }
}
IDE::System proc invokeTclProc proc {
    set arguments [list]
    set defargCount 0
    foreach arg [::info args $proc] {
         if {[::info default $proc $arg val]} {
            lappend arguments [list $arg $val]
            incr defargCount
         } else {
            lappend arguments $arg 
         }
    }
    my invokeTclProcWithArg $proc $arguments $defargCount
}
IDE::System proc invokeTclProcWithArg {proc arg {defargumentsCount 0}} {
    if {$arg eq ""} {
       set r [$proc]
    } else {
       while 1 {
          set ret [IDE::IDialogEntry getValueWithCancel "$proc\ngive the parameter list\n$arg"]
          if {$ret eq "_cancel"} return
                   if {[lindex $arg end] eq "args" && [llength $ret]>=[llength $arg]-1-$defargumentsCount} break
          if {[llength $ret]<=[llength $arg] && [llength $ret]>=[llength $arg]-$defargumentsCount} break
          IDE::Dialog message {Wrong length of param list}
       }
       set r [namespace eval :: $proc $ret]
    }
    if {$r eq ""} {
        IDE::Dialog message "empty result from $proc \n args :[string range $r 0 30]"
     } else {
        my inspectString $r
     }
}
IDE::System proc isDatabase {} {
   my instvar isDatabase
   if {[info exists isDatabase]} {
      return 1
   } else {
      return 0
   }
}
IDE::System proc isIgnoreIDEComponents {} {
    my set ignoreIDE
}
IDE::System proc isTkNeverThan84 {} {
    global tk_version
    expr {$tk_version>=8.4}
}
IDE::System proc isWindowsPlatform {} {
    global tcl_platform
    expr {$tcl_platform(platform) eq "windows"}
}
IDE::System proc loadExtras extra {
   if {$extra eq "sqlDebuger"} {
       if {[IDE::SystemConfigMap loadComponentFromAny xdobry::sqlDebug]} { 
          SqlDebugger debug
       }
   } elseif {$extra eq "Configuration"} {
       if {[IDE::SystemConfigMap loadComponentFromAny IDEConfiguration]} {
           IDE::ConfigmapBrowser newBrowser
       }
   } elseif {$extra eq "ExtendedDebugger"} {
       IDE::SystemConfigMap loadComponentFromAny IDEExtendedDebugger
       IDE::ExtendedDebugger initializeDebugger
       IDE::Dialog message "Please restart your code browsers to get breakpoint support and extended System menu"
   } else {
       IDE::Dialog error "$extra is unknown"
   }
}
@ IDE::System proc logObosoleteCall {} {
description {please use this method from a obsolet method
for log the obsolete call for this method}
}
IDE::System proc logObosoleteCall {} {
    set calllevel [expr {[info level]-1}]
    set method [info level $calllevel]
    set expr "!\[catch self\] && \[self proc\]==\"$method\""
    set isobject [uplevel #$calllevel [list expr $expr]]
    if {$isobject} {
        set object [uplevel #$calllevel {list [self]}]
        set class [uplevel #$calllevel {list [self class]}]
        if {[$object isclass] || $class eq "" || $class eq "{}"} {
            puts "obsolete method call: $object proc $method"
        } else {
            puts "obsolete method call: $class instproc $method"
       }
    } else {
        puts "obsolete proc call: $method"
    }
}
IDE::System proc openHTMLBrowser url {
    # Taken from WIKI Page 557
    global tcl_platform

    # It *is* generally a mistake to switch on $tcl_platform(os), particularly
    # in comparison to $tcl_platform(platform).  For now, let's just regard it
    # as a stylistic variation subject to debate.
    switch $tcl_platform(os) {
        Darwin {
            set command [list open $url]
        }
        HP-UX -
        Linux  -
        SunOS {
            foreach executable {firefox mozilla netscape iexplorer opera lynx
            w3m links galeon konquerer mosaic firefox amaya
            browsex elinks} {
                set executable [auto_execok $executable]
                if [string length $executable] {
                    # Do you want to mess with -remote?  How about other browsers?
                    set command [list $executable $url &]
                    break
                }
            }
        }
        {Windows 95} -
        {Windows NT} {
            set command "[auto_execok start] {} [list $url]"
        }
    }
    if [info exists command] {
        if [catch {eval exec $command} err] {
            tk_messageBox -icon error -message "error '$err' with '$command'"
        }
    } else {
        tk_messageBox -icon error -message  "Please ($tcl_platform(os), $tcl_platform(platform)) is not yet ready for browsing."
    }
}
IDE::System proc refreshComponentView component {
  if {[Object isobject IDE::CompViewDB]} {
       set nclass IDE::CompViewDB
  } else {
       set nclass IDE::CompView
  }
  foreach obj [$nclass info instances] {
       $obj refreshComponentView $component
  }
}
IDE::System proc resetMenuStruct {} {
    set mobj [self]::ms
    if {[Object isobject $mobj]} {
        $mobj destroy
        my getMenuStruct
    }
}
IDE::System proc showBusyWhile script {
    update idletasks
    set win [focus]
    if {$win ne ""} {
        set win [winfo toplevel $win]
    }
    if {$win eq ""} { 
        set win .
    }
    set alt [$win cget -cursor]
    $win configure -cursor clock
    uplevel $script
    $win configure -cursor $alt
}
IDE::System proc showFreshMethods {} {
   set list [ide::lcollect each [IDE::MethodDescription getFreshInserted] {
        $each printStringShort}]
   if {[llength $list]==0} {
       IDE::Dialog message "No fresh-inserted methods"
       return
   }
   IDE::MethodBrowser newBrowserList $list fresh-inserted
}
IDE::System proc signalComponentsChanged {} {
  if {[Object isobject IDE::CompViewDB]} {
       set nclass IDE::CompViewDB
  } else {
       set nclass IDE::CompView
  }
  foreach obj [$nclass info instances] {
       $obj showComponents
  }
}
IDE::System proc substituteString string {
     namespace eval :: subst [list $string]
}
IDE::System proc tryBrowseAsObjectList string {
    if {![info complete $string]} {return 0}
    if {[catch {set len [llength $string]}]} {return 0}
    if {[llength $string]==1} {return 0}
    foreach obj $string {
       if {![Object isobject $obj]} {
           return 0
       }
    }
    IDE::ObjectBrowser browseObjectsList $string
    return 1
}
IDE::System proc unknown args {
    error "Unknow [self] $args"
}
@ IDE::System proc versionAllCoreComponents {} {
description {IDE::SystemConfigMap loadComponentsFromList [IDE::SystemConfigMap getCleanedLoadList [concat [my getExtraComponents] [my getCoreComponents]]]}
}
IDE::System proc versionAllCoreComponents {{versionInfo {}}} {
   foreach cname [concat [my getExtraComponents] [my getCoreComponents]] {
        set cobj [IDE::Component getCompObjectForNameIfExist $cname]
        if {$cobj ne "" && [$cobj isPersistent] && ![$cobj isclosed]} {
            if {$versionInfo ne ""} {
               $cobj setVersionInfo $versionInfo
            }
            $cobj versionEdition
        }
   }
}
IDE::System initializeAfterLoad

